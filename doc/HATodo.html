<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.61 [en] (X11; I; Linux 2.2.5-22 i686) [Netscape]">
   <meta name="Author" content="Alan Robertson">
   <meta name="Description" content="This is the current task list (or to do list) for the High-Availability Linux Project">
   <meta name="Keywords" content="RAS, reliability, availability, serviceability, Linux, HA, Linux-HA, HA-Linux, schedules, todo, tasks">
   <title>Linux-HA Project Task List</title>
</head>
<body>

<h1>
Linux-HA Project Task List</h1>
This page describes a set of Linux-HA Phase I activities that need to be
done.&nbsp; There is also a documentation team whose activities I haven't
listed here, because I don't know enough about what needs to be done and
how it should be done to break it up into distinct tasks.
<p>The purpose of this list is to track all the things we think need doing,
and hopefully match them up to people who will do them.&nbsp; <i><b>Perhaps
you?</b>&nbsp; </i>If you see a task you are interested in, or want to
add tasks to the list or comment on it, contact
<a href="mailto:alanr@henge.com">Alan
Robertson</a>.
<br>&nbsp;
<h2>
Organization of Activities</h2>
Linux-HA phase I is divided into three basic areas:
<ol>
<li>
Heartbeat and cluster management services</li>

<li>
HA resource implementations</li>

<li>
Diagnostics</li>
</ol>

<h2>
HA Resource Implementations</h2>
Anything that can move from one machine to another (processes, IP addresses,
MAC addresses, filesystems) are implemented as resources.&nbsp; Lots of
interesting activities fall under this category.&nbsp; For example, IP
address takeover is in this category, filesystem replication and takeover
is in this category.&nbsp; Lots of things are implemented as resources.&nbsp;
This is where we get into properly handling the great diversity of things
that people want to put into HA systems.&nbsp; Some of these resource types
will require specialized hardware to test.&nbsp; If you want to see a particular
configuration supported, you may have to create the resource for it.
<p>Resources are basically objects with four member functions:
<ul>
<li>
<b>start</b> - enable or take over the resource</li>

<li>
<b>stop</b> - disable or give up the resource</li>

<li>
<b>status</b> - tell whether the resource is currently enabled</li>

<li>
<b>info</b> - provide human-readable information about the resource type
(used by GUI configuration tools, etc.)</li>
</ul>

<table BORDER WIDTH="100%" NOSAVE >
<tr>
<td>Activity</td>

<td>Description</td>

<td>DependsOn</td>

<td>WhoDo?</td>
</tr>

<tr>
<td>MACaddr</td>

<td>MAC address resource implementation</td>

<td></td>

<td></td>
</tr>

<tr>
<td>SharedFS</td>

<td>Shared filesystem takeover.&nbsp; Useful for multi-interface RAID boxes
and shared SCSI implementations.</td>

<td></td>

<td></td>
</tr>

<tr>
<td>NBD</td>

<td>Network block device /&nbsp; Mirroring Resource.&nbsp; This implements
the "poor-man's file synchronization" described on the list</td>

<td></td>

<td>alanr (?)</td>
</tr>

<tr>
<td>NBD-NFS</td>

<td>Design a resource sharing fileystem strategy based on NBD and NFS.&nbsp;
Implement the resource type for it.</td>

<td>NBD</td>

<td></td>
</tr>

<tr>
<td>Intermezzo</td>

<td>Intermezzo file sharing strategy.&nbsp; This may not have to be a resource
(?)</td>

<td></td>

<td></td>
</tr>

<tr>
<td >IPaddr-bcast</td>

<td>Fix IPaddr so that it handles netmasks and broadcast
addresses correctly.&nbsp; Probably involves changing findip.c.</td>

<td></td>

<td>alanr <B>DONE</b> 0.4.3.</td>
</tr>

</table>

<h2>
Related Activities</h2>
Things that don't fall into one of the other categories show up here...
<br>&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<tr >
<td>Activity</td>

<td >Description</td>

<td>DependsOn</td>

<td>WhoDo?</td>
</tr>

<tr>
<td>FileSync</td>

<td>Transactional file synchronization between nodes.</td>

<td></td>

<td>Lars Marowsky-Bree (?)</td>
</tr>

<tr>
<td>GGUI</td>

<td>GNOME-based configuration and status GUI [can KGUI and GGUI share code?]</td>

<td></td>

<td></td>
</tr>

<tr>
<td>KGUI</td>

<td>KDE-based configuration and status GUI [can KGUI and GGUI share code?]</td>

<td></td>

<td></td>
</tr>

<tr>
<td>GFS</td>

<td>Test GFS with Linux-HA...?</td>

<td></td>

<td></td>
</tr>

<tr>
<td>LVS</td>

<td>Figure out how to best integrate Linux-HA with the LVS project.</td>

<td></td>

<td></td>
</tr>
</table>

<h2>
Diagnostics Activities</h2>
Linux-HA Phase I needs a diagnostics subsystem to notice and handle things
like hardware and software failures that aren't complete node failures.&nbsp;
This is where that will be carried out.
<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td>Activity</td>

<td>Description</td>

<td>DependsOn</td>

<td>WhoDo?</td>
</tr>

<tr>
<td><b><font color="#3333FF">DiagFrame</font></b></td>

<td>Implement a Diagnostics API framework, or just adopt Mon and/or its
API.</td>

<td></td>

<td></td>
</tr>

<tr >
<td>EtherDiag</td>

<td>Implement a dead ethernet check for serial ports using new code for
ethernet diagnostics stuff</td>

<td >DiagFrame</td>

<td></td>
</tr>

<tr>
<td>HBDiags</td>

<td>Implement a disconnect check (RTS, DCD) for serial ports.&nbsp; This
would be triggered on demand from Mon or called directly from heartbeat
as needed.&nbsp; It should probably exist in a library version and an a.out
version.</td>

<td>DiagFrame</td>

<td></td>
</tr>
</table>

<h2>
Testing Activities</h2>
Lots of things need testing.&nbsp; Linux-HA needs special attention in
the testing department.&nbsp; This is the beginning of such a list.
<table BORDER WIDTH="100%" NOSAVE >
<tr >
<td>Activity</td>

<td >Description</td>

<td>DependsOn</td>

<td>WhoDo?</td>
</tr>

<tr>
<td>ConfigRegress</td>

<td>Configuration regression testing database containing valid and invalid
configurations for testing the input validation below.</td>

<td></td>

<td></td>
</tr>

<tr>
<td>TestPlan</td>

<td>Write a test plan for Phase I of Linux HA delineating specific test
configurations and test cases that we really mean to have work.</td>

<td></td>

<td></td>
</tr>
</table>

<h2>
Heartbeat and Cluster Manager Activities</h2>
These things are at the heart of Linux-HA.&nbsp; You'll notice that many
of them are marked as critical.&nbsp; Lots of fun stuff to be done here.
<table BORDER WIDTH="100%" NOSAVE >
<tr>
<td>Activity</td>

<td>Description</td>

<td>DependsOn</td>

<td>WhoDo?</td>
</tr>

<tr>
<td><b><font color="#3333FF">PartCluster</font></b></td>

<td>Detect and perform basic recovery from a partitioned cluster condition.&nbsp;
Of course, this won't unscramble shared SCSI filesystems that might have
occured as a result of a partitioned cluster :-)</td>

<td></td>

<td></td>
</tr>

<tr>
<td><b><font color="#3333FF">CMFrame</font></b></td>

<td>Create framework for "real" cluster manager.&nbsp; This constitutes
the APIs and supporting code allowing a cluster manager to be written</td>

<td>NPhase</td>

<td></td>
</tr>

<tr>
<td><b><font color="#3333FF">NPhase</font></b></td>

<td>Create an n-phase commit protocol similar to IBM's Phoenix cluster
services.&nbsp; Pages 424-430 in "<a href="http://www.amazon.com/exec/obidos/ASIN/0138997098/002-4921041-8360613">In
Search of Clusters</a>".&nbsp; See especially pages 428 and 429.</td>

<td></td>

<td></td>
</tr>

<tr>
<td><b><font color="#3333FF">CM1</font></b></td>

<td>Create the first cluster manager.&nbsp; A translation of the current
methodology into a cluster manager structure.&nbsp; May be a throwaway.</td>

<td>CMFrame, HBProtocol (before release)</td>

<td></td>
</tr>

<tr>
<td><b><font color="#3333FF">CM2</font></b></td>

<td>Creat the first <i>real</i> cluster manager.&nbsp; Must support an
arbitary number of nodes.&nbsp; Probably a voting/quorum-based cluster
manager.</td>

<td>CM1</td>

<td></td>
</tr>

<tr>
<td>InputCheck</td>

<td>Verify and Validate system configuration rigorously before starting
up.&nbsp; Provide a standalone configuration validation tool or input checking
mode for heartbeat.</td>

<td></td>

<td></td>
</tr>

<tr>
<td>SysLog</td>

<td>change ha_log() functions to use syslog.</td>

<td></td>

<td></td>
</tr>

<tr>
<td>SecKeeps</td>

<td>Optionally allow the secondary host to keep the resources it has when
the primary comes back online.</td>

<td></td>

<td></td>
</tr>

<tr>
<td>HBSec</td>

<td>Authenticate intracluster packets for heartbeat, etc.&nbsp; This
provides both error checking and security.&nbsp; Could simply add a auth_packet
entry point, and then we can plug our favorite authentication method into
it, and even allow the method to be chosen in the configuration file.&nbsp;
This would allow people with secure networks to use crc without encryption,
people in a more hostile environment could use HMAC-SHA1 with a
shared secret, etc.
Current thinking is to model the key file and authentication after
the methods used by NTP.</td>
<td></td>
<td>Mitja Sarp,
<br>
Neal McBurnett (consulting)</td>
</tr>

<tr>
<td>Restart heartbeat processes</td>
<td>Heartbeat should be able to restart its processes that die.
This is intended to allow for the possibility that one day a bug
might be found in the code which would cause it to die.
A little infrastructure work to support this effort is in 0.4.3.
Heavens! Perish the thought!  :-)
</td>
<td></td>
<td></td>
</tr>

<tr>
<td>Reconfig</td>
<td>Should be able to update configurations without shutting down the
cluster and restarting it.
This could be accomplished in lots of different ways.  From a local kill -1 type
approach, to a global synchronized cluster restart.
</td>
</tr>


<tr>
<td><b><font color="#3333FF">HBProtocol</font></b></td>

<td>Fix the protocol so that lost packets are retransmitted,
not just discovered.</td>
<td></td>
<td>alanr</td>
</tr>



<tr>
<TD>syslog-rsc</TD>
<td>	Make the cluster-wide syslog a cluster resource.
	This may require a little thought to make it reliable, and keep messages
	from getting lost during transitions.
	Maybe have each message logged to two hosts?
</td>

<td>SysLog</td>
<td></td>
</tr>



<tr>
	<TD>buffers</TD>
	<td>
	Should inspect code and modify to eliminate the possibility of
	buffer overrun attacks.  This is especially true of the
	messaging code.
	</td>
	<td></td>
	<td></td>
</tr>

<tr>
	<TD>patchdoc</TD>
	<td>
		Should document my expectations for patch submission.
		This should include a little bit about coding style.
	</td>
	<td></td>
	<td></td>
</tr>

<tr>
	<TD>TrimScripts</TD>
	<td>
		Should trim the number of scripts and how much they control.
		Scripts are fine, but heartbeat has a few too many...
		A few were trimmed for 0.4.3.
		In particular, the heartbeat process should instigate 
		resource acquisition, on startup, and relinquishment on
		shutdown, and not rely on the scripts that call it to
		do that.  It's probably OK to use scripts in the process,
		but starting heartbeat by itself should cause resources
		to be acquired, and killing it should cause them to be
		given up.
	</td>
	<td></td>
	<td>alanr</td>
</tr>

<tr>
<TD>debugoutput</TD>
<td>Heartbeat debuginfo doesn't go into debug-log</td>
<td></td>
<td></td>
</tr>

<tr>
<TD>manpage</TD>
<td>Write wonderful man pages for heartbeat, heartbeat.cf and ipresources
</td>
<td></td>
<td></td>
</tr>

<tr>
<TD>DEBUG</TD>
<td>	Make SIGUSR1 increment debug level, and SIGUSR2 decrement it.
</td>
<td></td>
<td>alanr <B>DONE</B>. 0.4.3.</td>
</tr>

<tr>
<TD>memloss</TD>
<td>
	Memory leaks are a danger since messages are allocated dynamically.
	There are a few things to do about it:  1) track buffer usage and make
	stats appear in the log from time to time.
	2) Document how to properly use and dispose of messages in the code.
	Use SIGUSR1 or SIGUSR2 to get message allocation stats.
</td>
<td></td>
<td>alanr <B>DONE</B>. 0.4.3.</td>
</tr>
<tr>
<td>FHS</td>

<td>Make Linux-HA file placement conform to the Linux Filesystem Hierarchy
Standard.</td>

<td></td>

<td>alanr <B>DONE</B>.  0.4.3.</td>
</tr>

</table>

<p>Activities in<b><font color="#3333FF"> bold blue</font></b> are challenging,
critical activities.
</body>
</html>
