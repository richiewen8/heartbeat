<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (Win98; U) [Netscape]">
</head>
<body>
<b><font size=+2><font color="#000000">Synchronizing</font> Disks for HA</font></b>
<p><b><font size=+1>What is this document?</font></b>
<br><i>This is only ONE way to keeps nodes in synchronization for a high
availability cluster.&nbsp; It suits my needs and may be a good</i>
<br><i>starting block for others so I'm sharing it.&nbsp; Your mileage
may vary.</i>
<p><i>We use this on a web server to update ~1GB worth of documents in
sync every 10 minutes.&nbsp; Depending on how quickly your files change,
you may be able to update more data, more frequently.&nbsp; I would not
recommend using this without a private fast ethernet channel, i.e. an extra
NIC in each node connected via a crossover cable.</i>
<p><i>To determine whether this method would be appropriate for you, you
may wish to do this:</i>
<ol>
<li>
<i>Set the minimum update rate you find acceptable (say, 3 minutes).</i></li>

<li>
<i>Conservatively approximate the amount of data you would expect to change
in 3 minutes (200MB)</i></li>

<li>
<i>Assuming you can count on 6MB/sec from your fast ethernet, multiply
this by 1/3 of your update time.&nbsp; Why?&nbsp; You need to account for
rsync (relatively slow executing) to determine what needs updating and
disk write time.&nbsp; In our example, this would give us 360MB worth of
updates per cycle.</i></li>
</ol>
<i>Of course, you can always do what I did - set it up and see if it updates
fast enough.&nbsp; The scripts I've provided will notify you if it kicks
off again before the previous one finished.......</i>
<p><i><font color="#000000">One last item:&nbsp; rsync with the --delete
option is </font><font color="#FF0000">dangerous</font><font color="#000000">!&nbsp;
Make sure your command options point to the proper destination!&nbsp; Test
this on non-critical data.&nbsp; And test it again.</font></i>
<br>&nbsp;
<p><b><font size=+1>What you'll need:</font></b>
<p>&nbsp;&nbsp;&nbsp; 1.&nbsp; A distribution of SSH.&nbsp; <font color="#FF0000">PLEASE
- SSH is NOT freeware.&nbsp; Respect their license!</font>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
You can get it at:&nbsp; <a href="ftp://ftp.cs.hut.fi/pub/ssh">ftp://ftp.cs.hut.fi/pub/ssh</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Mirrors and additional info can be found at:&nbsp; <a href="http://www.csua.berkeley.edu/ssh-howto.html">http://www.csua.berkeley.edu/ssh-howto.html</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
License information is available at:&nbsp; <a href="http://www.ssh.fi/sshprotocols2/licensing/ssh2_non-commercial_licensing.html">http://www.ssh.fi/sshprotocols2/licensing/ssh2_non-commercial_licensing.html</a>
<br>&nbsp;&nbsp;&nbsp; 2.&nbsp; A copy of rsync
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Found at <a href="http://rsync.samba.org/ftp/rsync/binaries/">http://rsync.samba.org/ftp/rsync/binaries/</a>&nbsp;&nbsp;&nbsp;
-OR-&nbsp;&nbsp; <a href="http://rsync.samba.org/ftp/rsync/rsync-2.3.1.tar.gz">http://rsync.samba.org/ftp/rsync/rsync-2.3.1.tar.gz</a>
<br>&nbsp;&nbsp; 3.&nbsp;&nbsp; Cron and stuff to mirror.
<p>&nbsp;&nbsp;&nbsp; <i><font size=-1>In actuality, you don't even need
SSH.&nbsp; You could use rsh instead, <b><font color="#FF0000">if your
security needs permit it.</font></b></font></i>
<p><b><font size=+1>Installing SSH</font></b>
<p><font color="#FF6600">START HERE for source distribution:</font>
<br>Untar your ssh distribution.&nbsp; You might want to read the INSTALL
file or HOWTO, but most can get by with the following:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><tt>./configure</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp; make</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp; make install</tt></b>
<p><font color="#FF6600">START HERE for rpm distribution after running
"rpm -ivh ssh_&lt;version#>.rpm":</font>
<br>Once this is done, make sure sshd is started on bootup.&nbsp; This
could be done via inetd or by placing (if ssh is installed to the default
location) "/usr/local/sbin/sshd" in you /etc/rc.d/rc.local file.&nbsp;
Type this in now to start it.
<p>Goto your ssh home directory:&nbsp;&nbsp;&nbsp; cd ~/.ssh
<p>Type "ls" to see what's in there if you like.
<p>Make sure that /usr/local/bin is in your path and type:&nbsp; "ssh-keygen"&nbsp;&nbsp;&nbsp;
This will create your identity.pub file.&nbsp;&nbsp; You'll need to enter
a passphrase.
<p>&nbsp;&nbsp;&nbsp; Copy the file "/etc/ssh_host_key.pub" to "/etc/ssh_known_hosts"
and open known_hosts for editing - it should look like this (<b>but all
one line!!!</b>):
<pre><i>&nbsp;&nbsp;&nbsp; 1024 35 1240189225834733795967<b>&lt;<font size=+1>MANY NUMBERS CUT</font>></b>354908432570619298213206066427 root@nodeA.domain.com</i></pre>
In front of the "1024", add whatever aliases you want this machine to be
know as separated by commas and no spaces:
<pre><i>&nbsp;&nbsp;&nbsp; nodeA,nodeA.domain.com,localnetA,localnetA.domain.com 1024 35 12401892258367<b>&lt;<font size=+1>MANY NUMBERS CUT</font>></b>35490843266427 root@nodeA.domain.com</i></pre>
Repeat all the above steps for your other cluster node.
<p>Merge the two "/etc/ssh_known_hosts" files so that they are identical
to the following:
<pre><i>&nbsp;&nbsp;&nbsp; nodeA,nodeA.domain.com,localnetA,localnetA.domain.com 1024 35 12401892258367<b>&lt;<font size=+1>MANY NUMBERS CUT</font>></b>35490843266427 root@nodeA.domain.com</i></pre>

<pre><i>&nbsp;&nbsp;&nbsp; nodeB,nodeB.domain.com,localnetB,localnetB.domain.com 1024 35 24354454234458<b>&lt;<font size=+1>MANY NUMBERS CUT</font>></b>82638761332764 root@nodeB.domain.com</i></pre>
On node A, type "cd ~/" and create a ".shosts"&nbsp; - For node A, if you
want to synchronize over the "localnet" route, it should look like this:
<pre><i>&nbsp;&nbsp;&nbsp; localnetB&nbsp;&nbsp;&nbsp; username&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font size=-2>I use root.&nbsp; I do not believe this is a risk if you consider your cluster as one machine - any SSH experts out there?</font></i></pre>
Create the corresponding "~/.shosts" on node B.
<p>Similar to the "/etc/ssh_known_hosts" file, we need a "~/.ssh/authorized_keys"
file.&nbsp; On node A, copy "~/.ssh/identity.pub" to "~/.ssh/authorized_keys".
<p>Open "~/.ssh/authorized_keys" for editing and merge the contents of
<b>node
B's</b> "~/.ssh/authorized_keys" to get something like this:
<pre><i>&nbsp;&nbsp;&nbsp; 1024 37 10847<b>&lt;MANY #s CUT></b>91475044341719 root@nodeA.domain.com
&nbsp;&nbsp;&nbsp; 1024 37 12544<b>&lt;MANY #s CUT></b>79835130992747 root@nodeB.domain.com</i></pre>
You should be all set.&nbsp; Try it out by typing on node A:&nbsp; "ssh
nodeB".&nbsp; You should be logged in to nodeB without having to type anything.
<br>&nbsp;
<p><b><font size=+1>Installing Rsync</font></b>
<p>Well, I'm not really going to tell you how to do this.&nbsp; I just
used the rpm.&nbsp; If that's not possible for you, I'm sure the good folks
at samba will have a nice README.Install for you to follow.&nbsp; However,
the binary link in the "What you'll need" section has binaries for just
about all flavors.&nbsp; Here's the link for the rpm:&nbsp;&nbsp; <a href="http://rsync.samba.org/ftp/rsync/binaries/redhat">http://rsync.samba.org/ftp/rsync/binaries/redhat</a>
<p><b><font size=+1>Determining your Rsync command</font></b>
<p>For our example, let's say you have a web server cluster.&nbsp; As a
result, you need the directory tree "/html" to be current on both nodes.&nbsp;
Assuming node A is the master, I would use the command from node A:
<pre><i>&nbsp;&nbsp;&nbsp; <tt>rsync --rsh=/usr/local/bin/ssh -naurvl --delete /html/ localnetB:/html</tt></i></pre>
Let's note a few things.&nbsp; First, since this will be used with cron,
you want to be sure that you use the full path for the ssh executable (and
the rsync executable for that matter).&nbsp; Second, you need to use the
same alias here that you used in ".shosts".&nbsp; Otherwise, you'll need
to log in - <b><font color="#000000">in</font></b>convenient for cron.&nbsp;
Also, note the "/html/" syntax.&nbsp; This last "/" is necessary - otherwise
you'll have the tree "/html/html" on your slave.&nbsp; Lastly, I used the
"-n" option.&nbsp; This is for a dry run.&nbsp; You want to do this to
make sure everything is copied/deleted as you would expect it.&nbsp; When
you put this in your crontab file, you'll leave off the "-n" option.&nbsp;
Similarly, the "-v" verbosity option is only for this test.&nbsp; In your
crontab entry, it will be replaced with the "-q" option for quiet.&nbsp;
Test the command now and make sure it does what you want - the "--delete"
option can be dangerous!
<p><b><font size=+1>Create your sync script and crontab entry</font></b>
<p>You now want to create the script which will run rsync every X minutes
via cron.&nbsp; I say script and not command because you want to account
for the startup case.&nbsp; Should your master fail and is just coming
up, you don't want it nuking the slave's directories until the master takes
over and receives any changes made in its absence.&nbsp; So, I use the
following perl script, call it "sync.pl":
<center><table BORDER BGCOLOR="#FFFFCC" NOSAVE >
<tr NOSAVE>
<td NOSAVE><i><tt>#!/usr/bin/perl</tt></i>
<p><i><tt># Only sync if serving IP</tt></i>
<br><i><tt>open(X,"/sbin/ifconfig|");</tt></i>
<br><i><tt>while(&lt;X>) {</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (/eth0:0/) {</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#make sure previous mirror has completed...</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (link("/etc/ha.d/ha.cf", "/var/lock/subsys/mirror")) {</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
system "/usr/bin/rsync --rsh=/usr/local/bin/ssh -aurlq --delete /html/
localnetB:/html";</tt></i>
<p><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# release rsync process</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unlink "/var/lock/subsys/mirror";</tt></i>
<p><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} else {</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
open(MAIL,"|mail username\@domain.com");</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print MAIL "Next RSYNC process starting before previous has completed!\n";</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
close MAIL;</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exit;</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></i>
<br><i><tt>}</tt></i></td>
</tr>
</table></center>
<b>NOTE:</b>&nbsp; This script makes the assumption that your cluster IPaddr
service is on eth0 as "eth0:0".&nbsp; Your setup may&nbsp; be different.&nbsp;
There are other ways of making sure the master has control (such as <i>IPaddr
&lt;IP> status</i>), but that was the way I wrote it and all my clusters
will service the IP on eth0 anyway.
<p><b>NOTE #2:</b>&nbsp; You may not want a mail fired off.&nbsp; You may
just want a log entry.&nbsp; You might want both.&nbsp; If you're unfamiliar
with perl, to add a log entry,
<br>substitute all the commands with "MAIL" in them above with the following:
<center><table BORDER BGCOLOR="#FFFFCC" NOSAVE >
<tr>
<td><i><tt>open(LOG,">>/var/log/ha-log");</tt></i>
<br><i><tt>$dstr = `date +%Y/%m/%d_%T`;</tt></i>
<br><i><tt>chomp $dstr;</tt></i>
<br><i><tt>print LOG "$dstr RSYNC: Process starting before previous one
completes!\n";</tt></i>
<br><i><tt>close LOG;</tt></i></td>
</tr>
</table></center>
At this point you want to create your crontab entry.&nbsp; The "lock file"
prevents more than one sync process from running at the same time, but
you want to have a decent idea of how often you need to synchronize and
how long it will take to synchronize.&nbsp; This brings me to explain the
"localnet" gibberish above. In my cluster, I have 3 NICs - one "global"and
two "local".&nbsp; The global is hooked into our company's network and
services the node and cluster IP address. One local is for a UDP heartbeat
via a crossover cable.&nbsp; The other also connects via a crossover cable
and is used solely for rsync.&nbsp; It's 100MBps and for our use, I'm not
even pushing it hard (yet?).&nbsp; Anyway, I'd recommend something similar
- they're cheap.&nbsp; If you're pushing the bandwidth limit, rsync may
not be appropriate for you.
<p>SO, once you determine how often you'll be synchronizing, type "crontab
-e" to modify your crontab entry.&nbsp; If you don't like vi, try using
"setenv EDITOR /usr/local/bin/emacs" (or export) to select emacs or a different
editor.&nbsp; If you want to synchronize every 10 minutes, your entry would
look like this:
<blockquote>
<pre><i>*/10 * * * * /script_directory/sync.pl &amp;> /dev/null</i></pre>
</blockquote>
You could also redirect output to some logfile if you desire, but keep
in mind how often it runs.
<p><b><font size=+1>Recovering from Failover</font></b>
<p>We're just about there now.&nbsp; The last case you need to consider
is when the master is coming back up after a failure.&nbsp; You want to
update the master's files to include any changes made while the slave was
handling the services.&nbsp; I do this via a services script in the /etc/ha.d/resources.d
directory. Typically, these scripts will be the same on both nodes.&nbsp;
For our purpose, however, we want the script to have different functions
on the slave as opposed to the master.&nbsp; They need to have the same
name, however, and I call it "mirror".
<p><b>NOTE:</b>&nbsp;&nbsp; You will want to be sure that any applications
writing to the synch'ed disks stop before giving back services to the master.&nbsp;
If these applications are controlled via the ipresources configuration
file, you can ensure this by listing the "mirror" script last.&nbsp; However,
if they are not, you will want to add an application exit to the beginning
of your mirror script.
<p><b>NOTE:</b>&nbsp; As you may be realizing, since the disks are re-synchronized
during the fail-back, your rsync time has an effect on the minimum downtime
in transitions.&nbsp; If your master has been down a long time, you may
want to bring it up without heartbeat and manually run the rsync commands.
<p>&nbsp;&nbsp;&nbsp; Here is "/etc/ha.d/resources.d/mirror" for the slave
node:
<center><table BORDER BGCOLOR="#FFFFCC" NOSAVE >
<tr NOSAVE>
<td NOSAVE><i><tt>#!/bin/sh</tt></i>
<br><i><tt>#</tt></i>
<p><i><tt># See how we were called.</tt></i>
<br><i><tt>case "$1" in</tt></i>
<br><i><tt>&nbsp; start)</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #Nothing to do.</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo -n "Slave mirror
start: "</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;</tt></i>
<br><i><tt>&nbsp; stop)</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #Need to put lockfile
on Master</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo -n "Slave mirror
stop: "</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /usr/local/bin/ssh
ha1 touch /var/lock/subsys/mirrorslave</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;</tt></i>
<br><i><tt>&nbsp; status)&nbsp;&nbsp;</tt></i>
<br><i><tt><font color="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font><font color="#000000">echo "Hi There!"</font><font color="#FF0000">&nbsp;&nbsp;</font></tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;</tt></i>
<br><i><tt>&nbsp; restart)</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $0 stop</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $0 start</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;</tt></i>
<br><i><tt>&nbsp; *)</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo "Usage: syslog
{start|stop|status|restart}"</tt></i>
<br><i><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit 1</tt></i>
<br><i><tt>esac</tt></i>
<p><i><tt>exit 0</tt></i></td>
</tr>
</table></center>
When the master fails, the slave will have the latest possible files via
cron and sync.pl, so there's nothing to do.&nbsp; However, when the master
comes back up, we want to notify it that there are changes to its files
that it must get from the slave.&nbsp; Hence, the lockfile.&nbsp; This
helps us discern between failovers, which needs the sync and a normal reboot,
for instance, which doesn't.
<p>Here's the master's mirror script:
<center><table BORDER BGCOLOR="#FFFFCC" NOSAVE >
<tr>
<td>
<pre><b><tt>#!/bin/sh
#
# Get updates from Slave when re-acquiring cluster IP
&nbsp;
&nbsp;
# See how we were called.
case "$1" in
&nbsp; start)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #Checks to see if failed over.&nbsp; If so, get update from slave.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; touch /var/lock/subsys/mirror
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if [ -f "/var/lock/subsys/mirrorslave" ]; then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo -n "Master start - Synchronizing from slave node: "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /usr/bin/rsync --rsh=/usr/local/bin/ssh -aurlq --delete ha2:/html/ /html
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rm -f /var/lock/subsys/mirrorslave
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rm -f /var/lock/subsys/mirror
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;
&nbsp; stop)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #Want to update slave's data before exiting.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if [ -f "/var/lock/subsys/mirror" ]; then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo -n "Master stop - Synchronizing data on slave node: "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link /etc/ha.d/ha.cf /var/lock/subsys/mirror
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /usr/bin/rsync --rsh=/usr/local/bin/ssh -aurlq --delete /html/ ha2:/html</tt></b></pre>
<b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rm -f /var/lock/subsys/mirror</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;</tt></b>
<br><b><tt>&nbsp; status)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;</tt></b>
<br><b><tt>&nbsp; restart)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $0 stop</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $0 start</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;</tt></b>
<br><b><tt>&nbsp; *)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo "Usage: syslog
{start|stop|status|restart}"</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit 1</tt></b>
<br><b><tt>esac</tt></b>
<p><b><tt>exit 0</tt></b></td>
</tr>
</table></center>
On startup, the master determines whether the slave has new information
for it.&nbsp; If so, it locks the cron process out and gets the updates.&nbsp;
This is only a safeguard, though, as the cron job can't possibly run until
this script has finished - the cluster IP is unavailable.&nbsp; When the
master is shutdown, the last thing it does is update the information on
the slave.&nbsp; This lock is necessary.
<p>Finally, you need to install the script in your ipresources on both
nodes - I would shut down heartbeat before making changes.&nbsp; You'll
want mirror to be the last service listed.&nbsp; For our webserver, it
would read:
<pre><i>&nbsp;&nbsp;&nbsp; nodeA 192.168.85.1 httpd mirror</i></pre>
So, the timeline for a recover from the slave is: "Slave releases IP, Slave
stops httpd, Slave runs mirror stop, Master runs mirror start, Master runs
http start, Master acquires IP".&nbsp; Bring your cluster back up and you
should be in business!
<br>&nbsp;
<p><b><font color="#FF0000"><font size=+3>Be Careful</font></font></b>
<p>Please test your setup on non-critical data first.&nbsp; There could
be a bad typo above or whatever.&nbsp; The "--delete" option can be dangerous.&nbsp;
You've been warned.
<br>&nbsp;
<p>Rev 0.0.2
<br>Rudy Pawul
<br>rpawul@iso-ne.com
</body>
</html>
