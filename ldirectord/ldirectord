#!/usr/bin/perl
#
# Linux Director Daemon - run "perldoc ldirectord" for details
# $Id: ldirectord,v 1.36 2001/08/28 07:53:32 jacob Exp $
# © 2000, Jacob Rief <jacob.rief@tiscover.com>
# This is GPL software. You should own a few hundred copies
# of the GPL by now. if not, get one at http://www.fsf.org

=head1 NAME

ldirectord - Linux Director Daemon

Daemon to monitor remote services and control Linux Virtual Server


=head1 SYNOPSIS

B<ldirectord> [B<-d>] [B<-h>] I<configuration> 
B<start>|B<stop>|B<restart>|B<reload>|B<status>


=head1 DESCRIPTION

B<ldirectord> is a daemon to monitor and administer real servers in a
cluster of load balanced virtual servers. B<ldirectord> typically is
started from heartbeat but can also be run from the command line. On
startup B<ldirectord> reads the file B</etc/ha.d/conf/>I<configuration>.
After parsing the file, entries for virtual servers are created on the LVS.
Now at regular intervals the specified real servers are monitored and if
they are considered alive, added to a list for each virtual server. If a
real server fails, it is removed from that list. Only one instance of
B<ldirectord> can be started for each configuration, but more instances of
B<ldirectord> may be started for different configurations. This helps to
group clusters of services.  Normally one would put an entry inside
B</etc/ha.d/haresources>

I<nodename virtual-ip-address ldirectord::configuration>

to start ldirectord from heartbeat.


=head1 OPTIONS

I<configuration>:
This is the name for the configuration as specified in the file
B</etc/ha.d/conf/>I<configuration>

B<-d> Don't start as daemon. Useful for debugging.

B<-h> Help. Print user manual of ldirectord.

B<start> the daemon for the specified configuration.

B<stop> the daemon for the specified configuration. This is the same as sending
a TERM signal the the running daemon.

B<restart> the daemon for the specified configuration. The same as stopping and starting.

B<reload> the configuration file. This is only useful for modifications
inside a virtual server entry. It will have no effect on adding or
removing a virtual server block. This is the same as sending a HUP signal to
the running daemon.

B<status> of the running daemon for the specified configuration.


=head1 SYNTAX

=head2 Description how to write configuration files

B<virtual = >I<(ip_address|hostname:portnumber|servicename)|firewall-mark>

Defines a virtual service by IP-address (or hostname) and port (or
servicename) or firewall-mark.  A firewall-mark is an integer greater than
zero. The configuration of marking packets is controled using the C<-m>
option to B<ipchains>(8).  All real services and flags for a virtual
service must follow this line immediately and be indented.

B<checktimeout = >I<n>

Defines the number of second until a real server is declared dead. Default
is 5 seconds. If defined in virtual server section then the global value
is overridden.

B<connecttimeout = >I<n>

Not used.

B<negotiatetimeout = >I<n>

Defines the number of seconds to wait for TCP/IP timeouts. Default is
defined by the operating system. If defined in virtual server section
then the global value is overridden.

B<checkinterval = >I<n>

Defines the number of second between server checks. Default is 10 seconds.

B<autoreload = >[B<yes>|B<no>]

Defines if <ldirectord> should continuously check the configuration
file for modification. If this is set to 'yes' and the configuration
file changed on disk, the configuration is automatically reloaded.
Default is no.

B<callback = ">I</path/to/callback>B<">

If this directive is defined, B<ldirectord> automatically calls
the executable I</path/to/callback> after the configuration
file has changed on disk. This is useful to update the configuration
file through B<scp> on the other heartbeated host. The first argument
to the callback is the name of the configuration.

This directive might also be used to restart B<ldirectord> automatically
after the configuration file changed on disk. However, if B<autoreload>
is set to yes, the configuration is reloaded anyway.

B<fallback = >I<ip_address|hostname[:portnumber|sercvicename]>

the server onto which a webservice is redirected if all real
servers are down. Typically this would be 127.0.0.1 with
an emergency page.

This directive may also appear within a virtual server, in which
case it will overide the global fallback server, if set.


B<logfile = ">I</path/to/logfile>B<">

an alternative logfile might be specified with this directive.


B<execute = ">I<configuration>B<">

Use this directive to start an instance of ldirectord for
the named I<configuration>.


B<supervised>

If this directive is specified, the daemon does not go into background mode.
All log-messages are redirected to stdout instead of a logfile.
This is useful to run B<ldirectord> supervised from daemontools.
See http://untroubled.org/rpms/daemontools/ or http://cr.yp.to/daemontools.html
for details.


=head2 Section virtual

The following commands must follow a B<virtual> entry and must be indented
with a minimum of 4 spaces or one tab.

B<real => I<ip_address|hostname[-E<gt>ip_address|hostname][:portnumber|servicename>] B<gate>|B<masq>|B<ipip> [I<weight>] [B<">I<request>B<", ">I<receive>B<">]

Defines a real service by IP-address (or hostname) and port (or
servicename). If the port is omitted then a 0 will be used, this is
intended primarily for fwmark services where the port for real servers is
ignored. Optionally a range of IP addresses (or two hostnames) may be
given, in which case each IP address in the range will be treated as a real
server using the given port. The second argument defines the forwarding
method, must be B<gate>, B<ipip> or B<masq>.  The thrid argument is
optional and defines the weight for that real server. The last two
arguments are optional. They define a request-receive pair to be used to
check if a server is alive. They override the request-receive pair in the
virtual server section. These two strings must be quoted. If the request
string starts with I<http://...> the IP-address of the real server is
overridden, otherwise the IP-address of the real server is used. This may
be used to send a request over a transparent proxy.

=head2 More than one of these entries may be inside a virtual section:

B<checktype = >I<negotiate>|I<connect>|I<N>|I<off>|I<on>

Type of check to perform. Negotiate sends a request and matches a receive
string. Connect only attemts to make a TCP/IP connection, thus the the
request and receive strings may be omitted.  If checktype is a number then
negotiate and connect is combined so that after each N connect attempts one
negotiate attempt is performed. This is useful to check often if a service
answers and in much longer intervalls a negotiating check is done.  Off
means no checking will take place and no real or fallback servers will be
activated. Default is I<negotiate>.

B<service = http>|B<https>|B<ftp>|B<none>

The type of service to monitor. None denotes a service that will not be
monitored. If the port specfied for the virtual server is 80 the default
service is B<http>.  If the port specified is 443 the default service is
B<https>.  If the port specified is 21 the default service is B<ftp>.
Otherwise the default service is B<none>.

B<checkport = >I<n>

Number of port to monitor. Sometimes check port differs from service port.
Default is port specified for the real server.

B<request = ">I<uri to requested object>B<">

This object will be requested each checkinterval seconds on each real
server.  The string must be inside quotes. Note that this string may be
overridden by an optional per real-server based request-string.

B<receive = ">I<string to compare>B<">

If the requested result contains this I<string to compare>, the real server
is declared alive. The string must be inside quotes. Note that this string
may be overridden by an optional per real-server based receive-string.

B<login = ">I<username>B<">

Username to use to login to FTP server. Default is anonymous.


B<passwd = ">I<password>B<">

Password to use to login to FTP server. Default is ldirectord\@<hostname>,
where hostname is the environment variable HOSTNAME evaluated at run time.


B<scheduler = rr>|B<wrr>|B<lc>|B<wlc>|B<lblc>|B<lblcr>

Scheduler to be used for loadbalance. Default is "wrr".

B<persistent => I<n>

Number of seconds for persistent client connections.

B<netmask => I<w.x.y.z>

Netmask to be used for granularity of persistent client connections.

B<protocol = tcp>|B<udp>|B<fwm>

Protocol to be used. If the virtual is specified as an IP address and port
then it must be one of tcp or udp and will default to tcp. If a firewall
mark then the protocol must be fwm, which is the default.


=head1 FILES

B</etc/ha.d/ldirectord.cf>

B</etc/ha.d/conf/>I<configuration>

B</var/log/ldirectord.log>

B</var/run/ldirectord.>I<configuration>B<.pid>

B</etc/>I<services>

=head1 SEE ALSO

L<ipvsadm>, L<heartbeat>


=head1 AUTHORS

Jacob Rief <jacob.rief@tiscover.com>

Horms <horms@vergenet.net>, <horms@valinux.com>

=cut

use strict;
use vars qw(
	    $AUTOCHECK
	    $CHECKINTERVAL
	    $CONNECTTIMEOUT
	    $LDIRECTORD
	    $LDIRLOG
	    $LD_TERM_CALLED
	    $NEGOTIATETIMEOUT
	    $RUNPID
            $CHECKTIMEOUT

	    $CALLBACK
	    $CFGNAME
	    $CMD
	    $CONFIG
	    $DEBUG
	    $FALLBACK
	    $SUPERVISED
	    $IPVSADM
	    $checksum
	    $initializing
	    $opt_d
	    $opt_h
	    $pid
	    $stattime
	    %LD_INSTANCE
	    @OLDVIRTUAL
	    @REAL
	    @VIRTUAL
);

# default values
$AUTOCHECK        = "no";
$CHECKINTERVAL    = 10;
$CHECKTIMEOUT     = 5;
$CONNECTTIMEOUT   = 0;
$LDIRECTORD       = "/usr/sbin/ldirectord"; # path onto myself
$LDIRLOG          = "/var/log/ldirectord.log";
$LD_TERM_CALLED   = 0;
$NEGOTIATETIMEOUT = 0;
$RUNPID           = "/var/run/ldirectord";


use Getopt::Std;
#use English;
#use Time::HiRes qw( gettimeofday tv_interval );
use Socket;
use Sys::Hostname;
#use LWP::Parallel::UserAgent;
use POSIX qw(setsid);

# command line options
getopts("dh");

$DEBUG = 3 if (defined $opt_d);

if ($DEBUG>0 and -f "./ipvsadm") {
	$IPVSADM="./ipvsadm";
} else {
	if (-x "/sbin/ipvsadm") {
		$IPVSADM="/sbin/ipvsadm";
	} elsif (-x "/usr/sbin/ipvsadm") {
		$IPVSADM="/usr/sbin/ipvsadm";
	} else {
		die "Can not find ipvsadm";
	}
}

# main code
if ($opt_h) {
	&system_wrapper("/usr/bin/perldoc -U $LDIRECTORD");
} else {
	$initializing = 1;
	init();
	ld_setup();
	ld_start();
	ld_cmd_children("start", %LD_INSTANCE);
	$initializing = 0;
	ld_main();
}
&ld_rm_file("$RUNPID.$CFGNAME.pid");
&ld_exit(0, "Reached end of \"main\"");


# functions
sub init
{
	# install signal handlers (this covers TERM)
	my $i;
	for $i (keys %SIG) {
		$SIG{"$i"} = \&ld_term;
	}

	# except CHLD, USR1, USR2 and __WARN__
	$SIG{'CHLD'} = "DEFAULT";
	$SIG{'USR1'} = "DEFAULT";
	$SIG{'USR2'} = "DEFAULT";
	$SIG{'__WARN__'} = "DEFAULT";

	# HUP is actually used
	$SIG{'HUP'} = \&ld_hup;

	# search for the correct configuration file
	if ( !defined $ARGV[0] ) {
	 	init_error("Usage ldirectord [-d] [configfile] \{start|stop|restart|reload|status\}\nRun ldirectord -h for more information");
	}
	if ( defined $ARGV[0] && defined $ARGV[1] ) {
		$CONFIG = $ARGV[0];
		if ($CONFIG =~ /([^\/]+)$/) {
			$CFGNAME = $1;
		}
		$CMD = $ARGV[1];
	} elsif ( defined $ARGV[0] ) {
		$CONFIG = "ldirectord.cf";
		$CFGNAME = "ldirectord";
		$CMD = $ARGV[0];
	}
	if ( $CMD ne "start" && $CMD ne "stop" && $CMD ne "status" && $CMD ne "restart" && $CMD ne "reload") {
	 	init_error("Usage ldirectord [-d] [configfile] \{start|stop|restart|reload|status\}\nType ldirectord -h for more information");
	}
	if ( -f "/etc/ha.d/$CONFIG" ) {
		$CONFIG = "/etc/ha.d/$CONFIG";
	} elsif ( -f "/etc/ha.d/conf/$CONFIG" ) {
		$CONFIG = "/etc/ha.d/conf/$CONFIG";
	} elsif ( ! -f "$CONFIG" ) {
		init_error("Config file $CONFIG not found");
	}
	my $oldpid;
	if (open(FILE, "<$RUNPID.$CFGNAME.pid")) {
		$_ = <FILE>;
		chomp;
		my $tmppid = $_;
		close(FILE);
		# Check to make sure this isn't a stale pid file
		if (open(FILE, "</proc/$tmppid/cmdline")) {
			$_ = <FILE>;
			if (/ldirectord/) {
				$oldpid = $tmppid;
			}
			close(FILE);
		}
	}
	if (defined $oldpid) {
		# Kill old daemon
		if ($CMD eq "stop") {
			kill 15, $oldpid;
			ld_exit(0, "Exiting from ldirectord stop");
		} elsif ($CMD eq "restart") {
			kill 15, $oldpid;
			while (-f "$RUNPID.$CFGNAME.pid") {
				# wait until old pid file is removed
			}
		} elsif ($CMD eq "reload") {
			kill 1, $oldpid;
			ld_exit(0, "Exiting from ldirectord reload");
		} elsif ($CMD eq "status") {
			print "ldirectord for $CONFIG is running with pid: $oldpid\n";
			ld_cmd_children("status", %LD_INSTANCE);
			ld_exit(0, "Exiting from ldirectord status");
		} else {
			init_error("ldirectord for $CONFIG is already running with pid: $oldpid");
		}
	} else {
		if ($CMD eq "status") {
			init_error("ldirectord is not running for $CONFIG");
		} elsif ($CMD ne "start") {
			init_error("ldirectord is not running for $CONFIG");
		}
	}
	read_config();
	undef @OLDVIRTUAL;

	# Run as daemon
	if ($SUPERVISED || defined $opt_d) {
		&ld_log("Starting Linux Director with pid: $$");
        } else {
		&ld_log("Starting Linux Director Daemon");
		&ld_daemon();
		open(FILE, ">$RUNPID.$CFGNAME.pid") || init_error("Can not open $RUNPID.$CFGNAME.pid");
		print FILE "$$\n";
		close(FILE);
	}
}


sub init_error
{
	my $msg = shift;
	chomp($msg);
	if (defined $opt_d) {
		&ld_log("$msg");
	} else {
		print STDERR "$msg\n";
	}
	ld_exit(1, "Initialisation Error");
}


# ld_term
# If we get a sinal then log it and quit
sub ld_term
{
        my ($signal) = (@_);
	print STDERR "ldirectord $CFGNAME received signal: $signal\n";
	if ($LD_TERM_CALLED){
		$SIG{'__DIE__'} = "IGNORE";
		$SIG{"$signal"} = "IGNORE";
		die("Exit Handler Repeatedly Called\n");
	}
	$LD_TERM_CALLED = 1;

	ld_cmd_children("stop", %LD_INSTANCE);
	ld_stop();
	&ld_log("Linux Director Daemon terminated on signal: $signal");
	&ld_rm_file("$RUNPID.$CFGNAME.pid");
	&ld_exit(0, "Linux Director Daemon terminated on signal: $signal");
}


sub ld_hup
{
        my ($signal) = (@_);
	&ld_log("Reloading Linux Director Daemon config on signal: $signal");
	&reread_config();
}


sub reread_config
{
	@OLDVIRTUAL = @VIRTUAL;
	my %OLD_INSTANCE = %LD_INSTANCE;
	eval {
		&read_config();
		my %NEW_INSTANCE = %LD_INSTANCE;
		&ld_setup();
		&ld_start();
		my $child;
		foreach $child (keys %OLD_INSTANCE) {
			if (exists $NEW_INSTANCE{$child}) {
				delete $OLD_INSTANCE{$child};
				delete $NEW_INSTANCE{$child};
				if (system("$LDIRECTORD $child reload")) {
					system("$LDIRECTORD $child start");
				}
			}
		}
		&ld_cmd_children("stop", %OLD_INSTANCE);
		&ld_cmd_children("start", %NEW_INSTANCE);
	};
	if ($@) {
		@VIRTUAL = @OLDVIRTUAL;
		%LD_INSTANCE = %OLD_INSTANCE;
	}
	undef @OLDVIRTUAL;
}


sub read_config
{
	undef @VIRTUAL;
	undef $CALLBACK;
	undef %LD_INSTANCE;
	undef $checksum;
	$SUPERVISED = 0;
	$stattime = 0;
	open(CFGFILE, "<$CONFIG") or
		&config_error(0, "can not open file $CONFIG");
	my $line = 0;
	while(<CFGFILE>) {
		$line++;
		outer_loop:
		if ($_ =~ /^virtual\s*=\s*(.*)/) {
			my $vattr = $1;
			my $ip_port = undef;
			my $fwm = undef;
			my $virtual_line = $line;
			my $fallback_line;
			my @rsrv_todo;
			if ($vattr =~ /^(\d+\.\d+\.\d+\.\d+):([0-9A-Za-z]+)/) {
				$ip_port = "$1:$2";
			} elsif ($vattr =~ /^([0-9A-Za-z._+-]+):([0-9A-Za-z]+)/) {
				$ip_port = "$1:$2";
			} elsif ($vattr =~ /^(\d+)/){
				$fwm = $1;
			}

			unless($ip_port or $fwm) {
				&config_error($line, 
					"invalid address for virtual server");
			}

			my (%vsrv, @rsrv);
			if ($ip_port) {
				$vsrv{checktype} = "negotiate";
			        $vsrv{protocol} = "tcp";
			} else {
			        $vsrv{fwm} = $fwm;
				$vsrv{checktype} = "negotiate";
			        $vsrv{protocol} = "fwm";
				$vsrv{service} = "none";
				$vsrv{port} = "0";
			}
			$vsrv{real} = \@rsrv;
			$vsrv{status} = 0;
			$vsrv{scheduler} = "wrr";
			$vsrv{request} = "/";
			$vsrv{receive} = "";
			$vsrv{login} = "anonymous";
			$vsrv{passwd} = "ldirectord\@$ENV{HOSTNAME}";
			$vsrv{checktimeout} = 0;
			$vsrv{connecttimeout} = 0;
			$vsrv{negotiatetimeout} = 0;
			$vsrv{num_connects} = 0;
			push(@VIRTUAL, \%vsrv);
			while(<CFGFILE>) {
				$line++;
				$_ =~ s/\t/    /g;
				unless ($_ =~ /^ {4,}(.*)/) {
					# As the protocol needs to be 
					# known to call getservbyname
					# all resolution must be delayed
					# until the protocol is finalised.
					# That is after the entire config
					# for a virtual service has been
					# parsed

					&_ld_read_config_fallback_resolve(
						$fallback_line, \%vsrv);
					&_ld_read_config_virtual_resolve(
						$virtual_line, \%vsrv, 
						$ip_port);
					&_ld_read_config_real_resolve(\%vsrv,
						\@rsrv_todo);

					#Arggh a goto :(
					goto outer_loop;
				}
				my $rcmd = $1;
				next if ($rcmd =~ /^#/);
				if ($rcmd =~ /^real\s*=\s*(.*)/) {
					push @rsrv_todo, [$1, $line];
				} elsif ($rcmd =~ /^request\s*=\s*\"(.*)\"/) {
					$1 =~ /(.+)/ or &config_error($line, "no request string specified");
					$vsrv{request} = $1;
					unless($vsrv{request}=~/^\//){
						$vsrv{request} = "/" . $vsrv{request};
					}

				} elsif ($rcmd =~ /^receive\s*=\s*\"(.*)\"/) {
					$1 =~ /(.+)/ or &config_error($line, "invalid receive string");
					$vsrv{receive} = $1;
				} elsif ($rcmd =~ /^checktype\s*=\s*(.*)/){
                                        lc($1);
					if ($1 =~ /(\d+)/ && $1>=0) {
						$vsrv{num_connects} = $1;
						$vsrv{checktype} = "combined";
					} elsif ( $1 =~ /(\w+)/ && ($1 eq "connect" || $1 eq "negotiate" || $1 eq "off" || $1 eq "on") ) {
						$vsrv{checktype} = $1;
					} else {
						&config_error($line, "checktype must be connect, negotiate, off, on or a positive number");
					}
				} elsif ($rcmd =~ /^checktimeout\s*=\s*(.*)/){
                                        $1 =~ /(\d+)/ && $1 or &config_error($line, "invalid check timeout");
                                        $vsrv{checktimeout} = $1;
				} elsif ($rcmd =~ /^connecttimeout\s*=\s*(.*)/){
                                        $1 =~ /(\d+)/ && $1 or &config_error($line, "invalid check timeout");
                                        $vsrv{connecttimeout} = $1;
				} elsif ($rcmd =~ /^negotiatetimeout\s*=\s*(.*)/){
                                        $1 =~ /(\d+)/ && $1 or &config_error($line, "invalid check timeout");
                                        $vsrv{negotiatetimeout} = $1;
				} elsif ($rcmd =~ /^checkport\s*=\s*(.*)/){
					$1 =~ /(\d+)/ or &config_error($line, "invalid port");
					( $1 > 0 && $1 < 65536 ) or &config_error($line, "checkport must be in range 1..65536");
					$vsrv{checkport} = $1;
				} elsif ($rcmd =~ /^login\s*=\s*\"(.*)\"/) {
					$1 =~ /(.+)/ or &config_error($line, "invalid login string");
					$vsrv{login} = $1;
				} elsif ($rcmd =~ /^passwd\s*=\s*\"(.*)\"/) {
					$1 =~ /(.+)/ or &config_error($line, "invalid password");
					$vsrv{passwd} = $1;
				} elsif ($rcmd =~ /^load\s*=\s*\"(.*)\"/) {
					$1 =~ /(\w+)/ or &config_error($line, "invalid string for load testing");
					$vsrv{load} = $1;
					lc($1);
				} elsif ($rcmd =~ /^scheduler\s*=\s*(.*)/) {
					$1 =~ /(\w+)/ && ($1 eq "rr" || $1 eq "wrr" || $1 eq "lc" || $1 eq "wlc" || $1 eq "lblc" || $1 eq "lblcr" )
					    or &config_error($line, "scheduler must be rr, wrr, lc or wlc");
					$vsrv{scheduler} = $1;
				} elsif ($rcmd =~ /^persistent\s*=\s*(.*)/) {
					$1 =~ /(\d+)/ or &config_error($line, "invalid persistent timeout");
					$vsrv{persistent} = $1;
				} elsif ($rcmd =~ /^netmask\s*=\s*(.*)/) {
					$1 =~ /(\d+\.\d+\.\d+\.\d+)/ or &config_error($line, "invalid netmask");
					$vsrv{netmask} = $1;
				} elsif ($rcmd =~ /^protocol\s*=\s*(.*)/) {
					lc($1);
					if ( $1 =~ /(\w+)/ ) {
						if ( $vsrv{protocol} eq "fwm" ) {
							if ($1 eq "fwm" ) {
								; #Do nothing, it is already set
							} else {
								&config_error($line, "protocol must be fwm if the virtual service is a fwmark (a number)");
							}
						} else {    # tcp or udp
							if ($1 eq "tcp" || $1 eq "udp") {
								$vsrv{protocol} = $1;
							} else {
								&config_error($line, "protocol must be tcp or udp if the virtual service is an address and port");
							}
						}
					} else {
						&config_error($line, "invalid protocol");
					}
				} elsif ($rcmd =~ /^service\s*=\s*(.*)/) {
					lc($1);
					$1 =~ /(\w+)/ && ($1 eq "http" || $1 eq "https"
					    || $1 eq "ftp" || $1 eq "none")
					    or &config_error($line, "service must be http, https, ftp or none");
					$vsrv{service} = $1;
				} elsif ($rcmd =~ /^sitename\s*=\s*(.*)/) {
					$1 =~ /(\w+)/ or &config_error($line, "invalid sitename");
					$vsrv{sitename} = $1;
				} elsif ($rcmd =~ /^fallback\s*=\s*(.*)/) {    # Allow specification of a virtual-specific fallback host
					$fallback_line=$line;
					$vsrv{fallback} = $1
				} else {
					&config_error($line, "Unknown command $_");
				}
			}
		}
		next if ($_ =~ /^\s*$/ || $_ =~ /^\s*#/);
		if ($_ =~ /^checktimeout\s*=\s*(.*)/) {
			($1 =~ /(\d+)/ && $1 && $1>0) or &config_error($line, "invalid timeout value");
			$CHECKTIMEOUT = $1;
		} elsif ($_ =~ /^connecttimeout\s*=\s*(.*)/) {
			($1 =~ /(\d+)/ && $1 && $1>0) or &config_error($line, "invalid timeout value");
			$CONNECTTIMEOUT = $1;
		} elsif ($_ =~ /^negotiatetimeout\s*=\s*(.*)/) {
			($1 =~ /(\d+)/ && $1 && $1>0) or &config_error($line, "invalid timeout value");
			$NEGOTIATETIMEOUT = $1;
		} elsif ($_ =~ /^checkinterval\s*=\s*(.*)/) {
			$1 =~ /(\d+)/ && $1 or &config_error($line, "invalid checkinterval value");
			$CHECKINTERVAL = $1;
		} elsif ($_ =~ /^fallback\s*=\s*(.*)/) {
			my $tcp=&ld_gethostservbyname($1, "tcp");
			my $udp=&ld_gethostservbyname($1, "udp");
			if(!defined($tcp) and !defined($udp)){
			    &config_error($line, 
			    	"invalid address for fallback server");
			}
			$FALLBACK = { "tcp" => $tcp, "udp" => $udp };
		} elsif ($_ =~ /^autoreload\s*=\s*(.*)/) {
			($1 eq "yes" || $1 eq "no")
			    or &config_error($line, "autoreload must be 'yes' or 'no'");
			$AUTOCHECK = $1;
		} elsif ($_ =~ /^callback\s*=\s*\"(.*)\"/) {
			$CALLBACK = $1;
		} elsif ($_ =~ /^logfile\s*=\s*\"(.*)\"/) {
			my $tmpLDIRLOG = $LDIRLOG;
			$LDIRLOG = $1;
			if (&ld_log("Reading file $CONFIG")) {
				&config_error($line, "unable to open logfile: $1");
				$LDIRLOG = $tmpLDIRLOG;
			}
		} elsif ($_ =~ /^execute\s*=\s*(.*)/) {
			$LD_INSTANCE{$1} = 1;
		} elsif ($_ =~ /^supervised/) {
			$SUPERVISED = 1;
		} else {
			if ($_ =~ /^timeout\s*=\s*(.*)/) {
				&config_error($line, "timeout directive deprciated in favour of checktimeout, negotiatetimeout or connecttimeout");
			}
			&config_error($line, "Unknown command $_");
		}
	}
	close(CFGFILE);
	return(0);
}


# _ld_read_config_virtual_resolve
# Note: Should not need to be called direclty, but won't do any damage if
#       you do.
# Resolve the server (ip address) and port for a virtual service
# pre: line: Line of configuration file fallback server was read from
#            Used for debugging messages
#      vsrv: Virtual Service to resolve server and port of
#      ip_port: server and port in the form
#               ip_address|hostname:port|service
# post: Take ip_port, resolve it as per ld_gethostservbyname
#       and set $vsrv->{server} and $vsrv->{port} accordingly.
#       If $vsrv->{service} is not set, then set it to "http",
#       "https", "ftp" or "none" if $vsrv->{port} is 80, 443, 21
#       or any other value respectivley
# reurn: none
#        Debugging message will be reported and programme will exit
#        on error.

sub _ld_read_config_virtual_resolve
{
	my($line, $vsrv, $ip_port)=(@_);

	if($ip_port){
		$ip_port=&ld_gethostservbyname($ip_port, $vsrv->{protocol});
		if($ip_port){
			($vsrv->{server}, $vsrv->{port}) = split /:/, $ip_port;
		}
		else {
			&config_error($line, 
				"invalid address for virtual service");
		}

		if(!defined($vsrv->{service})){
			if ($vsrv->{port} eq "80") {
				$vsrv->{service} = "http";
			} 
			elsif ($vsrv->{port} eq "443") {
				$vsrv->{service} = "https";
			} 
			elsif ($vsrv->{port} eq "21") {
				$vsrv->{service} = "ftp";
			} 
			else {
				$vsrv->{service} = "none";
			}
		}
	}
}


# _ld_read_config_fallback_resolve
# Note: Should not need to be called direclty, but won't do any damage if
#       you do.
# Resolve the fallback server for a virtual service
# pre: line: Line of configuration file fallback server was read from
#            Used for debugging messages
#      vsrv: Virtual Service to resolve fallback server of
# post: Take $vsrv->{fallback}, resolve it as per ld_gethostservbyname
#       and set $vsrv->{fallback} to the result
# reurn: none
#        Debugging message will be reported and programme will exit
#        on error.

sub _ld_read_config_fallback_resolve
{
	my($line, $vsrv)=(@_);

	if($vsrv->{fallback}){
		$vsrv->{fallback}=&ld_gethostservbyname($vsrv->{fallback}, 
			$vsrv->{protocol}) 
		or &config_error($line, 
			"invalid address for fallback server");
	}
}


# _ld_read_config_real_resolve
# Note: Should not need to be called direclty, but won't do any damage if
#       you do.
# Run thourgh the list of real servers read in the configuration file for a
# virtual server and parse these entries
# pre: vsrv: Virtual Service to parse real servers for
#      rsrv_todo: List of real servers read from config but not parsed.
#                 List is a list of list reference. The firest element in
#                 each list reference is the line read from the
#                 configuration after "real=". The second element is the
#                 line number, used for error reporting
# post: Run through rsrv_todo and parse real servers
# reurn: none
#        Debugging message will be reported and programme will exit
#        on error.

sub _ld_read_config_real_resolve
{
	my ($vsrv, $rsrv_todo)=(@_);

	my $i;
	my $str;
	my $line;
	my $ip1;
	my $ip2;
	my $port;
	my $flags;

	for $i (@$rsrv_todo) {
		($str, $line)=@$i;
		$str =~	 /(\d+\.\d+\.\d+\.\d+|[A-Za-z0-9.-]+)(->(\d+\.\d+\.\d+\.\d+|[A-Za-z0-9.-]+))?(:(\d+|[A-Za-z0-9-]+))?\s+(.*)/
			or &config_error($line, 
				"invalid address for real server" .
                                " (wrong format)");
		$ip1=$1;
		$ip2=$3;
                if(defined($5)){
		   $port=$5;
                }
                else {
                   $port="0";
                }
		$flags=$6;
		$ip1=&ld_gethostbyname($ip1);
                unless( defined($ip1) ) {
			&config_error($line, 
                                "invalid address for real server" .
                                " (could not resolve host)");
                }
		if( defined($port) ){
			$port=&ld_getservbyname($port);
                        unless( defined($port) ){
				&config_error($line, 
                                        "invalid port for real server" .
                                        " (could not resolve port)");
                        }
		}
		if ( defined ($ip2) ) {
			$ip2=&ld_gethostbyname($ip2);
                        unless( defined ($ip2) ) {
				&config_error($line, 
                                        "invalid address for real server" .
                                        " (could not resolve end host)");
                        }
			&add_real_server_range($line, $vsrv, $ip1, $ip2, 
                                $port, $flags);
		} else {
			&add_real_server($line, $vsrv, $ip1, $port, $flags);
		}
	}
}


# add_real_server_range
# Add a real server for each IP address in a range
# pre: line: line number real server was read from
#            Used for debugging information
#      vsrv: virtual server to add real server to
#      first: First IP address in range
#      last: First IP address in range
#      port: Port of real servers
#      flags: Flags for real servers. Should be of the form
#             gate|masq|ipip [<weight>] [">I<request>", "<receive>"]
# post: real servers are added to virtual server
# return: none
#         Debugging message will be reported and programme will exit
#         on error.

sub add_real_server_range
{
	my ($line, $vsrv, $first, $last, $port, $flags) = (@_);

        my (@tmp, $first_i, $last_i, $i, $rsrv);

	if ( ($first_i=&ip_to_int($first)) <0 ) {
		&config_error($line, "Invalid IP address: $first");
	}
	if ( ($last_i=&ip_to_int($last)) <0 ) {
		&config_error($line, "Invalid IP address: $last");
	}

	if ($first_i>$last_i) {
		&config_error($line, 
			"Invalid Range: $first-$last: First value must be " .
			"less than or equal to the second value");
	}

	# A for loop didn't seem to want to work
	$i=$first_i;
	while ( $i le $last_i ) {
		&add_real_server($line, $vsrv, &int_to_ip($i), $port, $flags);
		$i++;
	}
}


# add_real_server
# Add a real server to a virtual
# pre: line: line number real server was read from
#            Used for debugging information
#      vsrv: virtual server to add real server to
#      ip: IP address of real server
#      port: Port of real server
#      flags: Flags for real server. Should be of the form
#             gate|masq|ipip [<weight>] [">I<request>", "<receive>"]
# post: real server is added to virtual server
# return: none
#         Debugging message will be reported and programme will exit
#         on error.

sub add_real_server
{
	my ($line, $vsrv, $ip, $port, $flags) = (@_);

	my $ref;
	my $realsrv=0;
	my $request;
	my $receive;

	$flags =~ /(\w+)(.*)/ && ($1 eq "gate" || $1 eq "masq" || $1 eq "ipip")
	    or &config_error($line, 
	    	"forward method must be gate, masq or ipip");

	my $rsrv=$vsrv->{"real"};

	my $fwd = $1;
	if ($2 =~ /\s+(\d+)(\s+(.*))?/) {
		my $weight = $1;
		if ($3 =~ /\"(.*)\",\s*\"(.*)\"/) {
			$request = $1;
			$receive = $2;
			unless($request=~/^\//){
				$request = "/" . $request;
			}
			push(@$rsrv, {"server"=>$ip, "port"=>$port, 
				"forward"=>$fwd, "weight"=>$weight, 
				"request"=>$request, "receive"=>$receive});
		} else {
			push(@$rsrv, {"server"=>$ip, "port"=>$port, 
				"forward"=>$fwd, "weight"=>$weight});
		}
	} elsif ($2 =~ /\s+\"(.*)\",\s*\"(.*)\"/) {
		$request = $1;
		$receive = $2;
		unless($request=~/^\//){
			$request = "/" . $request;
		}
		push(@$rsrv, {"server"=>$ip, "port"=>$port, 
			"forward"=>$fwd, "request"=>$request, 
			"receive"=>$receive});
	} else {
		push(@$rsrv, {"server"=>$ip, "port"=>$port, "forward"=>$fwd});
	}

        my $real    = $vsrv->{"protocol"}.":".$ip.":".$port;
	my $virtual = $vsrv->{"protocol"}.":".&get_virtual($vsrv);
	for my $r (@REAL){
		if($r->{"real"} eq $real){
			my $ref=$r->{"virtual"};
			push(@$ref, $virtual);
			$realsrv=1;
			last;
		}
	}
	if($realsrv==0){
		push(@REAL, { "real"=>$real, "virtual"=>[ $virtual ] });
	}
}


sub config_error
{
	my ($line, $msg) = @_;
	if (defined $opt_d || $initializing==1) {
		if ($line>0) {
			print STDERR "Error [$pid] reading file $CONFIG at line $line: $msg";
		} else {
			print STDERR "Error: $msg\n";
		}
	} else {
		if ($line>0) {
			&ld_log("Error [$pid] reading file $CONFIG at line $line: $msg");
		} else {
			 &ld_log("Error: $msg\n");
		}
	}
	if ($initializing) {
		&ld_rm_file("$RUNPID.$CFGNAME.pid");
		&ld_exit(2, "config_error: Configuration Error");
	} else {
		die;
	}
}


sub ld_setup
{
	for my $v (@VIRTUAL) {
		if ($$v{protocol} eq "tcp") {
			$$v{proto} = "-t";
		} elsif ($$v{protocol} eq "udp") {
			$$v{proto} = "-u";
		} elsif ($$v{protocol} eq "fwm") {
			$$v{proto} = "-f";
		}
		$$v{flags} = "$$v{proto} " .  &get_virtual($v) . " ";
		$$v{flags} .= "-s $$v{scheduler} " if defined ($$v{scheduler});
		if (defined $$v{persistent}) {
			$$v{flags} .= "-p $$v{persistent} ";
			$$v{flags} .= "-M $$v{netmask} " if defined ($$v{netmask});
		}
		my $real = $$v{real};
		for my $r (@$real) {
			if ($$r{forward} eq "masq") {
				$$r{forw} = "-m";
			} elsif ($$r{forward} eq "gate") {
				$$r{forw} = "-g";
			} elsif ($$r{forward} eq "ipip") {
				$$r{forw} = "-i";
			} else {
				$$r{forw} = " ";
			}
			if (defined $$r{weight}) {
				 $$r{wght} = "-w $$r{weight}";
			} else {
				 $$r{wght} = " ";
			}
			$$r{status} = -1;
        		if (defined $$r{request} && defined $$r{receive}) {
				my $uri = $$r{request};
				$uri =~ s/^\///g;
				if ($$r{request} =~ /$$v{service}:\/\//) {
					my $port=(defined $$v{checkport}?$$v{checkport}:$$r{port});
					$$r{url} = "$$v{service}:\/\/$$r{server}:$port\/$uri";
				} else {
					my $port=(defined $$v{checkport}?$$v{checkport}:$$r{port});
					$$r{url} = "$$v{service}:\/\/$$r{server}:$port\/$uri";
				}
			} else {
				my $uri = $$v{request};
				$uri =~ s/^\///g;
				my $port=(defined $$v{checkport}?$$v{checkport}:$$r{port});
				$$r{url} = "$$v{service}:\/\/$$r{server}:$port\/$uri";

                		$$r{request} = $$v{request} unless defined $$r{request};
                		$$r{receive} = $$v{receive};
			}
			if ($$v{checktype} eq "combined") {
				$$r{num_connects} = 999999;
			} else {
				$$r{num_connects} = -1;
			}
		}
		$$v{status} = -1;
		$$v{checktimeout} = $CHECKTIMEOUT if ($$v{checktimeout}<=0);
		$$v{connecttimeout} = $CONNECTTIMEOUT if ($$v{connecttimeout}<=0);
		$$v{connecttimeout} = $$v{checktimeout} if ($$v{connecttimeout}<=0);
		$$v{negotiatetimeout} = $NEGOTIATETIMEOUT if ($$v{negotiatetimeout}<=0);
		$$v{negotiatetimeout} = $$v{checktimeout} if ($$v{negotiatetimeout}<=0);
	}
}


# ld_read_ipvsadm
# Parses the output of "ipvsadm -L -n" and puts into a structure of
# the following from:
# 
# {
#   (vip_address:vport|fwmark) protocol => {
#     "scheduler" => scheduler,
#     "persistent" => timeout,     # May be omitted
#     "netmask" => netmask,        # May be omitted
#     "real" => {
#       rip_address:rport => {
#         "forward" => forwarding_mechanism,
#         "weight"  => weight
#       },
#       ...
#     }
#   },
#   ...
# }
# 
# where: 
#   vip_address: IP address of virtual service
#   vport: Port of virtual service
#   fwmark: Firewall Mark of virtual service
#   scheduler: Scheduler for virtual service
#   timeout: Timeout for persistancy. Omitted if service is not persistant.
#   nemask: Netmask for persistancy. Omitted if service is not persistant.
#
#   rip_address: IP address of real server
#   rport: Port of real server
#   forwarding_mechanism: Forwarding mechanism for real server. 
#                         One of: gate, ipip, masq.
#   weight: Weight of real server
#
# pre: none
# post: ipvsadm -L -n is parsed
# result: reference to sructure detailed above.

sub ld_read_ipvsadm
{
	my %oldsrv;
	my $real_service;
	my $fwd;

	# read status of current ipvsadm -L -n
	unless(open(IPVS, "$IPVSADM -L -n |")){
          &ld_exit(-1, "Could not run $IPVSADM -L -n");
        }
	$_ = <IPVS>; $_ = <IPVS>; $_ = <IPVS>;

	while (<IPVS>) {
		if ($_ =~ /(\w+)\s+(\d+\.\d+\.\d+\.\d+\:\d+|\d+)\s+(\w+)\s+persistent\s+(\d+)\s+mask\s+(.*)/) {
			$real_service = "$2 ".lc($1);
			$oldsrv{"$real_service"} = {"real"=>{}, "scheduler"=>$3, "persistent"=>$4, "netmask"=>$5};
		} elsif ($_ =~ /(\w+)\s+(\d+\.\d+\.\d+\.\d+\:\d+|\d+)\s+(\w+)\s+persistent\s+(\d+)/) {
			$real_service = "$2 ".lc($1);
			$oldsrv{"$real_service"} = {"real"=>{}, "scheduler"=>$3, "persistent"=>$4};
		} elsif ($_ =~ /(\w+)\s+(\d+\.\d+\.\d+\.\d+\:\d+|\d+)\s+(\w+)/) {
			$real_service = "$2 ".lc($1);
			$oldsrv{"$real_service"} = {"real"=>{}, "scheduler"=>$3};
		} else {
			next;
		}
		while(<IPVS>) {
			last unless $_ =~ / ->\s+(\d+\.\d+\.\d+\.\d+\:\d+)\s+(\w+)\s+(\d+)/;
			if ($2 eq "Route") {
				$fwd = "gate";
			} elsif ($2 eq "Tunnel") {
				$fwd = "ipip";
			} elsif ($2 eq "Masq") {
				$fwd = "masq";
			}
			$oldsrv{"$real_service"}->{"real"}->{"$1"} = {"forward"=>$fwd, "weight"=>$3};
		}
		redo;
	}
	close(IPVS);

        return(\%oldsrv);
}

sub ld_start
{
	my $oldsrv;
	my $real_service;
	my $nv;
	my $nr;

	# read status of current ipvsadm -L -n
        $oldsrv=&ld_read_ipvsadm();
        
	# modify service, if changed
	foreach $nv (@VIRTUAL) {
		my $nreal = $$nv{real};
		$$nv{status} = 0;
		my $real_service = &get_virtual($nv) . " "  . $$nv{protocol};
		if (exists($oldsrv->{"$real_service"})) {
			# service exists, modify it
			&system_wrapper("$IPVSADM -E $$nv{flags}");
			&ld_log("Changed virtual server: " . &get_virtual($nv));
			my $ov = $oldsrv->{&get_virtual($nv) . " " . $$nv{protocol}};
			my $or = $$ov{real};
			for $nr (@$nreal) {
				if (exists($$or{"$$nr{server}:$$nr{port}"})) {
					&system_wrapper("$IPVSADM -e $$nv{proto} " . &get_virtual($nv) . " -R $$nr{server}:$$nr{port} $$nr{forw} $$nr{wght}");
					$$nr{status} = 1;
					$$nv{status}++;
					&ld_log("Changed real server: $$nr{server}:$$nr{port} ($$nv{status} x " . &get_virtual($nv) . ")\n");
					delete($$or{"$$nr{server}:$$nr{port}"});
				} else {
					$$nr{status} = 0;
				}
			}
			# remove remaining entries for real servers
			for my $k (keys %$or) {
				&system_wrapper("$IPVSADM -d $$nv{proto} " . &get_virtual($nv) . " -R $k");
				print ("Removed real server: $$nr{server}:$$nr{port} ($$nv{status} x " . &get_virtual($nv) . ")\n");
			}
			delete $oldsrv->{&get_virtual($nv) . " " . $$nv{protocol}};
		} else {
			# no such service, create a new one
			&system_wrapper("$IPVSADM -A $$nv{flags}");
			for $nr (@$nreal) {
				$$nr{status} = 0;
			}
			&ld_log("Added virtual server: " . &get_virtual($nv));
		}

		&fallback_on($nv);
	}

	# remove remaining entries for virtual servers
	foreach $nv (@OLDVIRTUAL) {
		if (exists($oldsrv->{&get_virtual($nv) . " " . $$nv{protocol}})) {
			# service still exists, remove it
			&system_wrapper("$IPVSADM -D $$nv{proto} " . &get_virtual($nv));
			&ld_log("Removed virtual server: " . &get_virtual($nv) . "\n");
		}
	}
}


sub ld_cmd_children
{
	my ($cmd, %children) = (@_);
	# instantiate other ldirectord, if specified
	my $child;
	foreach $child (keys %children) {
		&system_wrapper("$LDIRECTORD $child $cmd");
	}
}


sub ld_stop
{
	foreach my $v (@VIRTUAL) {
		my $real = $$v{real};
		foreach my $r (@$real) {
			if ($$r{status}>0) {
				&system_wrapper("$IPVSADM -d $$v{proto} " . &get_virtual($v) . " -R $$r{server}:$$r{port}");
				$$r{status} = 0;
				$$v{status}--;
				&ld_log("Removed real server: $$r{server}:$$r{port} ($$v{status} x " . &get_virtual($v) );
			}
		}
		&system_wrapper("$IPVSADM -D $$v{proto} " .  &get_virtual($v));
		&ld_log("Removed virtual server: " .  &get_virtual($v));
	}
}


sub ld_main
{
	# Main failover checking code
	while (1) {
		my @real_checked;
		foreach my $v (@VIRTUAL) {
			my $real = $$v{real};
			# unfortunately LWP::Paralell::UserAgent
			# does not work right now for https and
			# has some major problems with http

			# my $ua = new LWP::Parallel::UserAgent;
			# $ua->redirect(0);
			# $ua->max_hosts($#$real+1);
			# $ua->max_req($#$real+1);
			foreach my $r (@$real) {
				unless(grep(/^$$v{protocol}:$$r{server}:$$r{port}$/, @real_checked)){
					if ($$v{checktype} eq "negotiate" || $$r{num_connects}>=$$v{num_connects}) {
						&ld_debug(2, "Checking negotiate: real server=$$r{server}:$$r{port} (virtual: " .  &get_virtual($v) . ")");
						if ($$v{service} eq "http") {
							$$r{num_connects} = 0 if (check_http($v, $r));
							# my $req = new HTTP::Request(GET=>"$$r{url}");
							# $ua->register($req, \&http_received);
						} elsif ($$v{service} eq "https") {
							$$r{num_connects} = 0 if (check_https($v, $r));
						} elsif ($$v{service} eq "ftp") {
							$$r{num_connects} = 0 if (check_ftp($v, $r));
						} else {
							$$r{num_connects} = 0 if (check_none($v, $r));
						}
					} elsif ($$v{checktype} eq "connect" and $$v{protocol} ne "udp") {
						&ld_debug(2, "Checking connect: server=$$r{server}");
						check_connect($v, $r);
					} elsif ($$v{checktype} eq "off") {
						&ld_debug(2, "Checking off: No real or fallback servers to be added\n");
					} elsif ($$v{checktype} eq "on") {
						&ld_debug(2, "Checking on: Real servers are added without any checks\n");
						&service_set($v, $r, "up");
					} elsif ($$v{checktype} eq "combined") {
						&ld_debug(2, "Checking combined-connect: server=$$r{server}");
						if (check_connect($v, $r)) {
							$$r{num_connects}++;
						} else {
							$$r{num_connects} = 999999;
						}
					}
					push(@real_checked, "$$v{protocol}:$$r{server}:$$r{port}");
				}
			}
			# $ua->wait($$v{checktimeout});
		}
		check_cfgfile();
		sleep $CHECKINTERVAL;
	}
}


# sub http_received
# # callbackfunction for Parallel::UserAgent
# {
# 	my ($content, $respone, $proto) = @_;
# 	my $req = $$respone{_request};
# 	my $url = $$req{_uri};
# 	if ($url =~ /(http\w?):\/\/([^\/:]+)(.*)/) {
# 		my ($p, $s, $u) = ($1, $2, $3);
# 		$url = "$p://$s:80$u" if ($p eq "http" && $u =~ /^\//);
# 		$url = "$p://$s:443$u" if ($p eq "https" && $u =~ /^\//);
# 	}
# 	foreach $v (@VIRTUAL) {
# 		my $real = $$v{real};
# 		foreach $r (@$real) {
# 			if ($url eq $$r{url}) {
# 				my $receive_string = $$r{receive};
# 				if (!($receive_string =~ /.+/) || $content =~ /$receive_string/) {
# 					service_set($v, $r, "up");
# 				} else {
# 					service_set($v, $r, "down");
# 				}
# 			}
# 		}
# 	}
# 	return C_ENDCON;
# }


sub check_http
{
	use LWP::UserAgent;
	my ($v, $r) = @_;
	
	my $ua = new LWP::UserAgent;
	$ua->agent("LinuxDirector/0.1 ".$ua->agent);
	$ua->timeout($$v{negotiatetimeout});
	my $req = new HTTP::Request(GET=>"$$r{url}");
	my $res = $ua->request($req);
	my $recstr = $$r{receive};
	if ($res->is_success && (!($recstr =~ /.+/) || $res->content =~ /$recstr/)) {
		service_set($v, $r, "up");
		return 1;
	} else {
		service_set($v, $r, "down");
		return 0;
	}
}


sub check_https
{
	my ($v, $r) = @_;
	use Net::SSLeay;
	$Net::SSLeay::trace = 0;
	my $uri = $$v{request};
	my ($page, $result, %headers);
	{
		local $SIG{__WARN__};
		($page, $result, %headers)  = &Net::SSLeay::get_https($$r{server}, $$r{port}, $uri);
	}

	my $recstr = $$r{receive};
	if ($result =~ /error/i) {
		service_set($v, $r, "down");
		return 0;
	}
	if ( !($recstr =~ /.+/) || $page =~ /$recstr/ ) {
		service_set($v, $r, "up");
		return 1;
	}
	service_set($v, $r, "down");
	return 0;
}


sub check_connect
{
	my ($v, $r) = @_;

	my $port=(defined $$v{checkport}?$$v{checkport}:$$r{port});
	eval {
		local $SIG{'__DIE__'} = "DEFAULT";
		local $SIG{'ALRM'} = sub { die "Timeout Alarm" };
		&ld_debug(4, "Timeout is $$v{checktimeout}");
		alarm $$v{checktimeout};
		my $result = &ld_open_socket($$r{server}, $port, $$v{protocol});
		if ($result == 0) {
			# Failure to open the socket
			die("Couldn't open socket to $$r{server}:$port");
		} else {
			&ld_debug(3, "Connected to $1 (port $port)");
		}
	};
	alarm 0; # Cancel the alarm
	if ($@) {
		&service_set($v, $r, "down");
		&ld_debug(3, "Deactivated service $$r{server}:$$r{port}: $@");
		return 0;
	} else {
		&service_set($v, $r, "up");
		&ld_debug(3, "Activated service $$r{server}:$$r{port}");
		return 1;
	}
}


sub check_ftp
{
	use Net::FTP;
	my ($v, $r) = @_;
	my $ftp;
        local *READ_FH;
	local *WRITE_FH;

	pipe(\*READ_FH, \*WRITE_FH);
	select(\*WRITE_FH); $| = 1; select(STDERR);

	unless ($ftp = Net::FTP->new("$$r{server}:$$r{port}", Timeout=>$$v{negotiatetimeout})) {
		service_set($v, $r, "down");
		return 0;
	}
	$ftp->login($$v{login}, $$v{passwd});
	$ftp->cwd("/");
	$ftp->binary();
	$ftp->get("$$r{request}", \*WRITE_FH);
	$ftp->quit();
	close(\*WRITE_FH);
	while(<READ_FH>) {
		if (/$$r{receive}/) {
	 		service_set($v, $r, "up");
			close(\*READ_FH);
			return 1
		}
	}
	close(\*READ_FH);

	service_set($v, $r, "down");
	return 0;
}


# check_none
# Dummy function to check service if service type is none.
# Just activates the real server

sub check_none
{
	my ($v, $r) = @_;
	service_set($v, $r, "up");
	return 1;
}


# service_set
# Used to bring up and down real servers.
# This is the function you should call if you want to bring a real 
# server up or down.
# This function is safe to call regrdless of the current state of a 
# real server.
# Do _not_ call _service_up or _service_down directly.
# pre: v: virtual that the real service belongs to
#         Only used to determine the protocol of the service
#      r: real server to take down
#      state: up or down
#             up to bring the real service up
#             down to bring the real service up
# post: The real server is brough up or down for each virtual service
#       it belongs to.
# return: none

sub service_set()
{
	my ($v, $r, $state) = @_;

	my ($real, $virtual, $virt);

        # Return if the real server is already in the desired state
	return if ($$r{status}!=0 and $state=~/up/i);
	return if ($$r{status}!=1 and $state=~/down/i);

        # Find the real server in @REAL
	foreach $real (@REAL) {
		if($real->{"real"} eq "$$v{protocol}:$$r{server}:$$r{port}"){
			$virtual = $real->{"virtual"};
			last;
		}
	}
	return unless (defined($virtual));

	# Check each virtual service for the real server and make
	# changes as neccessary
	foreach $v (@VIRTUAL){
		my $qry=$$v{protocol} . ":" . &get_virtual($v);
		if (grep(/^$qry$/, @$virtual)) {
			if ($state=~/up/i) {
				$$r{status}=0;
				_service_up($v, $r);
				&ld_debug(2, "Enabled server=$$r{server}");
			} elsif ($state=~/down/i) {
				$$r{status}=1;
				_service_down($v, $r);
				&ld_debug(2, "Disabled server=$$r{server}");
			}
		}
	}
}


# _quiecent_service
# Make a real server quiecent
# Should be called by _service_down or fallback_off
# I.e. If you want to change the state of a real server call set_service.
#      If you call this function directly then ldirectord will lose track
#      of the state of real servers.
# If the real server exists (which it should) make it quiecent. If it
# doesn't exist, just leave it as it will be added by the _service_up code
# as appropriate.
# pre: v: reference to virtual service to with the real server belongs
#      rservice: service to restore. Of the form server:port for a tcp or
#                udp service. Of the form fwmark for a fwm service.
#      rforw: Forwarding mechanism of service. Sould be one of "-g" "-i" or
#             "-m"
#      tag: Tag to use for logging. Should be either "real" or "fallback"
# post: real service is taken up from the respective virtual service
#       if it is inactive
# return: none

sub _quiecent_service {
	my ($v, $rservice, $rforw, $tag) = (@_);

        my $oldsrv;
        my $ov;
        my $or;
        my $ipvsadm_args;
        my $log_args;

	$ipvsadm_args = "$$v{proto} " . &get_virtual($v) . " -R $rservice";
        $log_args = "$tag server: $rservice "
                    . "($$v{status} x " .  &get_virtual($v) . ")";

        $oldsrv=&ld_read_ipvsadm();
        $ov=$oldsrv->{&get_virtual($v) . " " . $v->{"protocol"}};
        if(defined($ov)){
                $or=$ov->{"real"}->{$rservice};
        }
        if(defined($or)){
                unless($or->{"weight"} eq 0 and
                        $or->{"forward"} eq $rforw){
                        &system_wrapper("$IPVSADM -e $ipvsadm_args $rforw -w 0");
	                &ld_log("Quiecent $log_args");
                }
        }
}


# _restore_service
# Make a retore a real server. The opposite of _quiecent_server.
# Should be called by _service_up or fallback_on
# I.e. If you want to change the state of a real server call set_service.
#      If you call this function directly then ldirectord will lose track
#      of the state of real servers.
# If the real server exists (which it should) make it quiecent. If it
# doesn't exist, just leave it as it will be added by the _service_up code
# as appropriate.
# pre: v: reference to virtual service to with the real server belongs
#      rservice: service to restore. Of the form server:port for a tcp or
#                udp service. Of the form fwmark for a fwm service.
#      rforw: Forwarding mechanism of service. Sould be one of "-g" "-i" or
#             "-m"
#      rwght: Weight of service. Sold be of the form "-w <weight>"
#             e.g. "-w 1"
#      tag: Tag to use for logging. Should be either "real" or "fallback"
# post: real service is taken up from the respective virtual service
#       if it is inactive
# return: none

sub _restore_service {
	my ($v, $rservice, $rforw, $rwght, $tag) = (@_);

        my $oldsrv;
        my $ov;
        my $or;
        my $ipvsadm_args;
        my $log_args;

	$ipvsadm_args = "$$v{proto} " . &get_virtual($v) 
                        . " -R $rservice $rforw $rwght";
        $log_args = "$tag server: $rservice "
                    . "($$v{status} x " .  &get_virtual($v) . ")";

        #if the server exists then restore its weight
        # otherwise add the server
        $oldsrv=&ld_read_ipvsadm();
        $ov=$oldsrv->{&get_virtual($v) . " " . $v->{"protocol"}};
        if(defined($ov)){
                $or=$ov->{"real"}->{$rservice};
        }
        if(defined($or)){
                unless("-r " . $or->{"weight"} eq $rwght and
                       $or->{"forward"} eq $rforw){
                        &system_wrapper("$IPVSADM -e $ipvsadm_args");
	                &ld_log("Restored $log_args");
                }
        }
        else {
                &system_wrapper("$IPVSADM -a $ipvsadm_args");
	        &ld_log("Added $log_args");
        }
}


# _service_up
# Bring a real service up if it is down
# Should be called by set_service only
# I.e. If you want to change the state of a real server call set_service.
#      If you call this function directly then ldirectord will lose track
#      of the state of real servers.
# pre: v: reference to virtual service to with the real server belongs
#      r: refernece to the real server to take down
# post: real service is taken up from the respective virtual service
#       if it is inactive
# return: none

sub _service_up
{
	my ($v, $r) = (@_);

	if ($$r{status}==0) {
                &_restore_service($v, $r->{server} . ":" . $r->{port}, 
                                  $r->{forw}, $r->{wght}, "real");
		$$r{status} = 1;
		$$v{status}++;
		&fallback_off($v);
	}
}


# _service_down
# Bring a real service down if it is up
# Should be called by set_service only
# I.e. if you want to change the state of a real server call set_service.
#      If you call this function directly then ldirectord will lose track
#      of the state of real servers.
# pre: v: reference to virtual service to with the real server belongs
#      r: refernece to the real server to take down
# post: real service is taken down from the respective virtual service
#       if it is active
# return: none

sub _service_down
{
	my ($v, $r) = @_;

	if ($$r{status}==1) {
                &_quiecent_service($v, $r->{server} . ":" . $r->{port}, 
                                  $r->{forw}, "real");
		$$r{status} = 0;
		$$v{status}--;
		&fallback_on($v);
	}
}


# fallback_on
# Turn on the fallback server for a virtual service if it is inactive
# pre: v: virtual to turn fallback service on for
# post: fallback server is turned on if it was inactive
# return: none

sub fallback_on
{
	my ($v) = (@_);

	my $fallback=&fallback_find($v);
	if (defined $fallback and $$v{status}==0) {
                _restore_service($v, $fallback, "", "-w 1", "fallback");
	}
}


# fallback_off
# Turn off the fallback server for a virtual service if it is active
# pre: v: virtual to turn fallback service off for
# post: fallback server is turned off if it was active
# return: none

sub fallback_off
{
	my ($v) = (@_);

	my $fallback=&fallback_find($v);
	if (defined $fallback and $$v{status}==1) {
                _quiecent_service($v, $fallback, "", "fallback");
	}
}


# fallback_find
# Determine the fallback for a virtual service
# pre: virtual: reference to a virtual service
# post: none
# return: $virtual->{"fallback"} if defined
#         else $FALLBACK->{$virtual->{"protocol"}} if defined
#         else undef

sub fallback_find
{
	my ($virtual) = (@_);

	if( defined $virtual->{"fallback"} ) {
		return($virtual->{"fallback"});
	} elsif ( defined($FALLBACK) ) {
		return($FALLBACK->{$virtual->{"protocol"}});
	}

	return;
}


sub check_cfgfile
{
	my ($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime) = stat($CONFIG);
	return if ($stattime==$mtime);
	$stattime = $mtime;
	use Digest::MD5 qw(md5 md5_hex);
	my $ctx = Digest::MD5->new;
	open(CFGFILE, "<$CONFIG") || &config_error(0, "can not open file $CONFIG");
	$ctx->addfile(*CFGFILE);
	close(CFGFILE);
	my $digest = $ctx->hexdigest;
	if (defined $checksum && $checksum ne $digest) {
		&ld_log("Configuration file '$CONFIG' has changed on disk");
		if ($AUTOCHECK eq "yes") {
			&ld_log(" - reread new configuration");
			&reread_config();
		} else {
			&ld_log(" - ignore new configuration\n");
		}
		if (-x $CALLBACK) {
			&system_wrapper("$CALLBACK $CONFIG");
		}
	}
	$checksum = $digest;
}


# ld_log
# Log a message to a file.
# File is opened and closed again as a primative means to
# make log rotation work
# pre: message: Message to write
# post: message and timetsamp is written to log file
# return: 0 on success
#         1 on error
sub ld_log
{
	my ($message) = (@_);

        my $now = localtime();

	&ld_debug(2, $message);
	chomp $message;
	if (defined $opt_d) {
		print STDERR "$message\n";
	} elsif ($SUPERVISED) {
		print "[$now] $message\n";
	} else {
		unless (open(LOGFILE, ">>$LDIRLOG")
		    && print LOGFILE "[$now|$CFGNAME] $message\n"
		    && close(LOGFILE)) {
			print STDERR "$message\n";
			return 1;
		}
	}
	return(0);
}


# ld_debug
# Log a message to a STDOUT.
# pre: priority: priority of message
#      message: Message to write
# post: message is written to STDOUT if $DEBUG >= priority
# return: none

sub ld_debug
{
	my ($priority, $message) = (@_);

	if ( $DEBUG >= $priority ) {
		chomp $message;
		print STDERR "DEBUG${priority}: $message\n";
	}
}


# system_wrapper
# Wrapper arround system command to log errors
# pre: LIST: arguments to pass to system()
# post: system is called and if it returns non-zero a failure message is logged
# return: none

sub system_wrapper
{
	my (@args)=(@_);
        &ld_log("Running system(@args)") if $DEBUG>2;
	system(@args) == 0 or &ld_log("system(@args) failed");
}


# ld_rm_file
# Remove a file, symink, or anything that isn't a directory
# and exists
# pre: filename: file to delete
# post: If filename does not exist or is a directory an
#       error state is reached
#       Else filename is delete
#       If $DEBUG >=2 errors are logged
# return: 0 on success
#         -1 on error

sub ld_rm_file
{
	my ($filename)=(@_);

	my ($status);

	if(-d "$filename"){
		&ld_debug(2, "ld_rm_file: $filename is a directory, skipping");
		return(-1);
	}
	if(! -e "$filename"){
		&ld_debug(2, "ld_rm_file: $filename doesn't exist, skipping");
		return(-1);
	}
	$status = unlink($filename);
	if($status!=1){
		&ld_debug(2, "ld_rm_file: Error deleting: $filename: $!");
	}
	return(($status==1)?0:-1)
}


# is_octet
# See if a number is an octet, that is >=0 and <=255
# pre: alleged_octet: the octect to test
# post: alleged_octect is checked to see if it is valid
# return: 1 if the alleged_octet is an octet
#         0 otherwise

sub is_octet
{
	  my ($alleged_octet)=(@_);

	  if($alleged_octet<0){ return 0; }
	  if($alleged_octet>255){ return 0; }

	  return(1);
}


# is_ip
# Check that a given string is an IP address
# pre: alleged_ip: string representing ip address
# post: alleged_ip is checked to see if it is valid
# return: 1 if alleged_ip is a valid ip address
#         0 otherwise

sub is_ip
{
	  my ($alleged_ip)=(@_);

	  #If we don't have four, . delimited numbers then we have no hope
	  unless($alleged_ip=~m/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/) { return 0; }

	  #Each octet mist be >=0 and <=255
	  unless(&is_octet($1)){ return 0; }
	  unless(&is_octet($2)){ return 0; }
	  unless(&is_octet($3)){ return 0; }
	  unless(&is_octet($4)){ return 0; }

	  return(1);
}


# ip_to_int
# Turn an IP address given as a dotted quad into an integer
# pre: ip_address: string representing IP address
# post: post ip_address is converted to an integer
# return: -1 if an error occurs
#         integer representation of IP address otherwise

sub ip_to_int
{
	  my ($ip_address)=(@_);

	  unless(&is_ip($ip_address)){ return(-1); }
	  unless($ip_address=~m/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/){ return(-1); }

	  return(((((($1<<8)+$2)<<8)+$3)<<8)+$4);
}


# int_to_ip
# Turn an IP address given as a dotted quad into an integer
# pre: ip_address: string representing IP address
# post: Decimal is converted to a dotted quad
# return: -1 if an error occurs
#        integer representation of IP address otherwise

sub int_to_ip
{
	my ($ip_address)=(@_);

	my $result = "";

	return(sprintf(
		"%d.%d.%d.%d",
		($ip_address>>24)&255,
		($ip_address>>16)&255,
		($ip_address>>8)&255,
		$ip_address&255
	));
}


# get_virtual
# Get the service for a virtual
# pre: nv: virtual to get the service for
# post: none
# return: fwmark of service if it is a fwm service
#         ip_address:port otherwise

sub get_virtual
{
	my ($nv) = (@_);

	if ($nv->{"protocol"} eq "fwm"){
		return $nv->{"fwm"};
	} else {
        	return $nv->{"server"} . ":" . $nv->{"port"};
	}
}


# ld_exit
# Exit and log a message
# pre: exit_status: Integer exit status to exit with
#                   0 wiil be used if parameter is omitted
#      message: Message to log when exiting. May be omitted
# post: If exit_status is non-zero or $DEBUG>2 then
#       message logged.
#       Programme exits with exit_status
# return: does not return

sub ld_exit
{
	my ($exit_status, $message)=(@_);
	unless(defined($exit_status)) { $exit_status=0; }
	unless(defined($exit_status)) { $message=""; }

	if ($exit_status!=0 or $DEBUG>2) {
		&ld_log("Exiting with exit_status $exit_status: $message");
	}
	exit($exit_status);
}


# ld_open_socket
# Open a socket connection
# pre: remote: IP address as a dotted quad of remote host to connect to
#      port: port to connect to
#      protocol: Prococol to use. Should be either "tcp" or "udp"
# post: A Socket connection is opened to the remote host
# return: Open socket
#         Programe dies on error (may be caught by calling function)

sub ld_open_socket
{
	my ($remote, $port, $protocol) = @_;
	my ($iaddr, $paddr, $pro, $result);

	$iaddr = inet_aton($remote) || die "no host: $remote";
	$paddr = sockaddr_in($port, $iaddr);
	$pro = getprotobyname($protocol);
	socket(SOCK, PF_INET, SOCK_STREAM, $pro) || die "socket: $!";
	$result = connect(SOCK, $paddr);
	close(SOCK) || die "close: $!" if ($result);
	return $result;
}


# daemon
# Close and fork to become a daemon.
#
# Notes from unix programmer faq
# http://www.landfield.com/faqs/unix-faq/programmer/faq/
#
# Almost none of this is necessary (or advisable) if your daemon is being
# started by `inetd'.  In that case, stdin, stdout and stderr are all set up
# for you to refer to the network connection, and the `fork()'s and session
# manipulation should *not* be done (to avoid confusing `inetd').  Only the
# `chdir()' and `umask()' steps remain as useful.
#
# Gratuitously over documented, because it can be
#
# Writen by Horms, horms@vergenet.net for an unrelated project while
# working for Zip World, http://www.zipworld.com.au/, 1997-1999.

sub ld_daemon
{
	# `fork()' so the parent can exit, this returns control to the command
	# line or shell invoking your program.  This step is required so that
	# the new process is guaranteed not to be a process group leader. The
	# next step, `setsid()', fails if you're a process group leader.
	&ld_daemon_become_child();

	# setsid()' to become a process group and session group leader. Since a
	# controlling terminal is associated with a session, and this new
	# session has not yet acquired a controlling terminal our process now
	# has no controlling terminal, which is a Good Thing for daemons.
	if(POSIX::setsid()<0){
		&ld_exit(-1, "ld_daemon: Could not setsid");
	}

	# fork()' again so the parent, (the session group leader), can exit.
	# This means that we, as a non-session group leader, can never regain a
	# controlling terminal.
	&ld_daemon_become_child();

	# `chdir("/")' to ensure that our process doesn't keep any directory in
	# use. Failure to do this could make it so that an administrator
	# couldn't unmount a filesystem, because it was our current directory.
	if(chdir("/")<0){
		&ld_exit(-1, "ld_daemon: Could not chdir");
	}

	# `umask(0)' so that we have complete control over the permissions of
	# anything we write. We don't know what umask we may have inherited.
	umask(0);

	# `close()' fds 0, 1, and 2. This releases the standard in, out, and
	# error we inherited from our parent process. We have no way of knowing
	# where these fds might have been redirected to. Note that many daemons
	# use `sysconf()' to determine the limit `_SC_OPEN_MAX'.  `_SC_OPEN_MAX'
	# tells you the maximun open files/process. Then in a loop, the daemon
	# can close all possible file descriptors. You have to decide if you
	# need to do this or not.  If you think that there might be
	# file-descriptors open you should close them, since there's a limit on
	# number of concurrent file descriptors.
	close(STDIN);
	close(STDOUT);
	close(STDERR);

	# Establish new open descriptors for stdin, stdout and stderr. Even if
	# you don't plan to use them, it is still a good idea to have them open.
	# The precise handling of these is a matter of taste; if you have a
	# logfile, for example, you might wish to open it as stdout or stderr,
	# and open `/dev/null' as stdin; alternatively, you could open
	# `/dev/console' as stderr and/or stdout, and `/dev/null' as stdin, or
	# any other combination that makes sense for your particular daemon.
	if(open(STDIN, "</dev/null")<0){
		&ld_exit(-1, "ld_daemon: Could not open /dev/null");
	}
	if(open(STDOUT, ">>/dev/console")<0){
		&ld_exit(-1, "ld_daemon: Could not open /dev/console");
	}
	if(open(STDERR, ">>/dev/console")<0){
		&ld_exit(-1, "ld_daemon: Could not open /dev/console");
	}
}


# ld_daemon_become_child
# Fork, kill parent and return child process
# pre: none
# post: process forkes and parent exits
#       All preocess exit with exit status -1 if an error occurs
# return: parent: exits
#         child: none  (this is the process that returns)
# Writen by Horms, horms@vergenet.net for an unrelated project while
# working for Zip World, http://www.zipworld.com.au/, 1997-1999.

sub ld_daemon_become_child
{
	my($status);

	$status = fork();

	if ($status<0){
		&ld_exit(-1, "ld_daemon_become_child: Could not fork: $!");
	}
	if ($status>0){
		&ld_exit(0, 
			"ld_daemon_become_child: Parent exiting as it should");
	}
}


# ld_gethostbyname
# Wrapper to gethostbyname. Look up the/an IP address of a hostname 
# If an IP address is given is it returned
# pre: name: Hostname of IP address to lookup
# post: gethostbyname is called to find an IP address for $name
#       This is converted to a string
# return: IP address
#         undef on error

sub ld_gethostbyname 
{
	my ($name)=(@_);

	my @host=gethostbyname($name);

	return((@host and defined($host[4]))?inet_ntoa($host[4]):undef);
}


# ld_getservbyname
# Wraper for getservbyname. Look up the port for a service name
# If a port is given it is returned.
# pre: name: Port or Service name to look up
# post: if $name is a number 
#         if 0<=$name<=65536 $name is returned
#         else undef is returned
#       else getservbyname is called to look up the port for the service
# return: Port
#         undef on error

sub ld_getservbyname 
{
	my ($name, $protocol)=(@_);

	if($name=~/^[0-9]+$/){ 
		return(($name>=0 and $name<65536)?$name:undef);
  	}

	my @serv=getservbyname($name, $protocol);

	return((@serv and defined($serv[2]))?$serv[2]:undef);
}


# ld_getservhostbyname
# Wraper for ld_gethostbyname and ld_getservbyname. Given a server of the
# form ip_address|hostname[:port|servicename] return ip_address[:port]
# pre: hostserv: Servver of the form ip_address|hostname[:port|servicename]
#      protocol: Protocol for service. Should be either "tcp" or "udp"
# post: lookups performed as per ld_getservbyname and ld_gethostbyname
# return: ip_address[:port]
#         undef on error

sub ld_gethostservbyname{
	my ($hostserv, $protocol) = (@_);

	my $ip;
	my $port;

	$hostserv =~ 
		/(\d+\.\d+\.\d+\.\d+|[A-Za-x0-9.-]+)(:(\d+|[A-Za-x0-9-]+))?/ 
		or return(undef);
	$ip=$1;
	$port=$3;

	$ip=&ld_gethostbyname($ip)  or return(undef);

	if(defined($port)){
		$port=&ld_getservbyname($port, $protocol) or return(undef);
		return("$ip:$port");
	}
	return($ip);
}

